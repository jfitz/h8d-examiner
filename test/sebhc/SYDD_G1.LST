                                                  	HEATH ASM #104.01.00.
                                                   	Page  1

                        *** 	SYDD - System Device Driver
                        *	Author: JG Letwin, Oct 1977
                        *	Transcribed by Bob Groh August 2009
                        *	SYDD is a system device driver for H17mini-floppy  
                        *	This file is the complete transcription of the entire orignal SYDD listing file (in  pdf format)

                        *	Editor: Notepad++
                        *	Format: pure text format with TAB delimiters
                        *	Revision Table
                        *	Version	Date	Author	Description
                        *	1.0	8/12/09	Bob Groh	Completed and combined whole listing
                        *	
                        *
O  042.200  000 000 000 
                        ****	Assembly Constants
   000.376              MI.CPI	EQU	376Q	CPI Instruction
   000.012              ERPTCNT	EQU	10	Soft Error Retry Count
O  042.203  000 000 000 
U  042.206              	XTEXT	MTR
U  042.206              	XTEXT	U8251
U  042.206              	XTEXT	ASCII
A                       	LON	C
U  042.206              	XTEXT 	HOSEDEF
O  042.206  000 000 000 
                        **	HOSDEF - Define HOS Parameter
                        *
   000.377              SYSCALL	EQU	377Q	Syscall Instruction
O  042.211  000 000 000 
A                       	ORG	0
                        *	Resident Functions
   042.214              .EXIT	DS	1	Exit (must be first)
   042.215              .SCIN	DS	1	SCIN (serial input)
   042.216              .SCOUT	DS	1	SCOUT (serial output)
   042.217              .PRINT	DS	1	PRINT
   042.220              .READ	DS	1	READ
   042.221              .WRITE	DS	1	WRITE
   042.222              .CONSL	DS	1	Set/clear console options
   042.223              .CLRCO	DS	1	Clear console buffer
   042.224              .SYSRES	DS	1	Preceeding functions are resident
O  042.225  000 000 000 
                        *	HOSOVL.SYS	Functions
A                       	ORG	40A
   042.230              .LINK	DS	1	LINK (must be first)
   042.231              .CTLC	DS	1	CTL-C
   042.232              .OPENR	DS	1	Open Read
   042.233              .OPENW	DS	1	Open Write
   042.234              .OPENU	DS	1	Open Update(?)
   042.235              .OPENC	DS	1	Open Channel (?)
   042.236              .CLOSE	DS	1	Close
   042.237              .POSIT	DS	1	Position
   042.240              .DELET	DS	1	Delete
   042.241              .RENAM	DS	1	Rename
   042.242              .SETTP	DS	1	Set top
   042.243              .DECODE	DS	1	Name decode
   042.244              .NAME	DS	1	Get file name from channel
   042.245              .CLEAR	DS	1	Clear channel
   042.246              .CLEARA	DS	1	Clear all channels
   042.247              .ERROR	DS	1	Look up error
                                                  	HEATH ASM #104.01.00.
                                                   	Page  2

   042.250              .CHFLG	DS	1	Change flags
   042.251              .DISMT	DS	1	Flag system disk dismounted
U  042.252              	XTEXT	DIRDEF
O  042.252  000 000 000 
                        ** 	Directory Entry Format
A                       	ORG	0
O  042.255  000 000 000 
   000.377              UP.EMP	EQU	377Q	Flags Entry Empty
   000.376              UP.CLR	EQU	376Q	Flags Entry empty, rest of dire also clear
O  042.260  000 000 000 
   042.263              DIR.NAM	DS	8	Space for file Name
   042.273              DIR.EXT	DS	3	Space for file Extension
   042.276              DIR.PRO	DS	1	Project
   042.277              DIR.VER	DS	1	Version
   042.300              DIRIDL	EQU	*	File identification length
O  042.300  000 000 000 
   042.303              DIR.CLU	DS	1	Cluster factor
   042.304              DIR.FLG	DS	1	Flags
   042.305              	DS	1	Reserved
   042.306              DIR.FGN	DS	1	First group number
   042.307              DIR.LGN	DS	1	Last group number
   042.310              DIR.CRD	DS	2	Creation Date
   042.312              DIR.ALD	DS	2	Last alteration date
   042.314              DIRELEN	EQU	*	Directory Entry length
U  042.314              	XTEXT	DEVDEF
O  042.314  000 000 000 
                        **	Device Table Entrys
A                       	ORG	0
   042.317              DEV.NAM	DS	2	Device Name
   042.321              DEV.RES	DS	1	Driver residence code
   000.001              DR.IM	EQU	00000001B	Driver in memory
   000.002              DR.PR	EQU	00000010B	Driver permanently resident
O  042.322  000 000 000 
   042.325              DEV.JMP	DS	1	Jump to processor
   042.326              DEV.DDA	DS	2	Driver address
   042.330              DEV.FLG	DS	1	Flag Byte
   000.001              DT.DD	EQU	00000001B	Directory Device
   000.002              DT.CR	EQU	00000010B	Capable of READ operation
   000.004              DT.CW	EQU	00000100B	Capable of WRITE operation
O  042.331  000 000 000 
   042.334              DEV.GRT	DS	2	Address of group reservation table (if directory)
   042.336              DEV.SPG	DS	1	Sectors per group this device
   042.337              DEV.MUM	DS	0	Mounted unit mask
   042.337              DEV.MNU	DS	1	Maximum number of units
   042.340              DEV.DVL	DS	2	Driver byte length
   042.342              DEV.DVG	DS	1	Driver routine group address
   042.343              DEV.DIR	DS	2	Directory first sector address
   042.345              DEV.GTS	DS	2	GRT sector number
O  042.347  000 000 000 
   042.352              DEVELEN	EQU	*	Device tble entry length
U  042.352              	XTEXT	H17DEF
O  042.352  000 000 000 
                        **	H17 Control Information
   000.177              DP.DC	EQU	07FH	Disk control port
   000.001              DF.HD	EQU	00000001B	Hole Detect
   000.002              DF.TO	EQU	00000010B	Track 0 detect
   000.004              DF.WP	EQU	00000100B	Write protect
   000.010              DF.SD	EQU	00001000B	Sync Detect
                                                  	HEATH ASM #104.01.00.
                                                   	Page  3

O  042.355  000 000 000 
   000.001              DF.WG	EQU	00000001B	Write gate enable
   000.002              DF.DSO	EQU	00000010B	Drive select 0
   000.004              DF.DS1	EQU	00000100B	Drive select 1
   000.010              DF.DS2	EQU	00001000B	Drive select 2
O  042.360  000 000 000 
   000.020              DF.MO	EQU	00010000B	Motor On (both drives)
   000.040              DF.DI	EQU	00100000B	Direction (0 = out)
   000.100              DF.ST	EQU	01000000B	Step command (active high)
   000.200              DF.WR	EQU	10000000B	Write enable RAM
O  042.363  000 000 000 
                        **	Disk UART ports and control flags
   000.174              UP.DP	EQU	07CH	Data port
   000.175              UP.FC	EQU	07DH	Fill Character
   000.175              UP.ST	EQU	07DH	Status flags
   000.176              UP.SC	EQU	07EH	Syn character (output)
   000.176              UP.SR	EQU	07EH	Sync reset (input)
O  042.366  000 000 000 
   000.001              UF.RDA	EQU	00000001B	Receive data available
   000.002              UF.ROR	EQU	00000010B	Receiver overrun
   000.004              UF.RPE	EQU	00000100B	Receiver parity error
   000.100              UF.FCT	EQU	01000000B	Fill character transmitted
   000.200              UF.TBM	EQU	10000000B	Transmitter buffer empty
O  042.371  000 000 000 
                        ** 	Character Definitions
   000.375              C.DSYN	EQU	0FDH	Prefix sync character
U  042.374              	XTEXT	ECDEF
O  042.374  000 000 000 
                        **	Error Code Definitions
A                       	ORG	0
   042.377              	DS	1	No error #0
   043.000              EC.EOF	DS	1	End of file
   043.001              EC.EOM	DS	1	End of media
   043.002              EC.ILC	DS	1	Illegal SYSCALL code
   043.003              EC.CNA	DS	1	Channel not available
   043.004              EC.DNS	DS	1	Device not suitable
   043.005              EC.IDN	DS	1	Illegal device name
   043.006              EC.IFN	DS	1	Illegal file name
   043.007              EC.NRD	DS	1	No room dor device driver
   043.010              EC.FNO	DS	1	channel not open
   043.011              EC.ILR	DS	1	Illegal request
   043.012              EC.FUC	DS	1	File name conflict
   043.013              EC.FNF	DS	1	File name not found
   043.014              EC.UND	DS	1	Unknown device
   043.015              EC.ICN	DS	1	Illegal channel number
   043.016              EC.DIF	DS	1	Directory full
   043.017              EC.IFC	DS	1	Illegal file contents
   043.020              EC.NEM	DS	1	Not enough memory
   043.021              EC.RF	DS	1	Read failure
   043.022              EC.WF	DS	1	Write failure
   043.023              EC.WPV	DS	1	Write protection violation
   043.024              EC.WP	DS	1	disk write protected
   043.025              EC.FAP	DS	1	file already present
   043.026              EC.DDA	DS	1	device driver abort
   043.027              EC.FL	DS	1	file locked
   043.030              EC.FAO	DS	1	file already open
   043.031              EC.IS	DS	1	illegal switch
   043.032              EC.UUN	DS	1	unknown unit number
                                                  	HEATH ASM #104.01.00.
                                                   	Page  4

   043.033              EC.FNR	DS	1	file name required
   043.034              EC.DIW	DS	1	device is not readable
   043.035              EC.UNA	DS	1	unit not available
   043.036              EC.ILV	DS	1	illegal value
   043.037              EC.ILO	DS	1	illegal option
U  043.040              	XTEXT	DDDEF	
O  043.040  000 000 000 
                        **	Device driver communication flags
                        *
A                       	ORG	0
   043.043              DC.REA	DS	1	Read
   043.044              DC.WRI	DS	1	Write
   043.045              DC.RER	DS	1	Read Regardless
   043.046              DC.OPR	DS	1	Open for read
   043.047              DC.OPW	DS	1	Open for write
   043.050              DC.OPU	DS	1	Open for update
   043.051              DC.CLO	DS	1	Close
   043.052              DC.ABT	DS	1	Abort
   043.053              DC.MOV	DS	1	Mount Device
U  043.054              	XTEXT	PICDEF
O  043.054  000 000 000 
                        **	PIC Format equivalences
                        *
A                       	ORG	0
   043.057              PIC.ID	DS	1	377Q = Binary file flag
   043.060              	DS	1	File type (FT.PIC)
   043.061              PIC.LEN	DS	2	Length of entire record
   043.063              PIC.PTR	DS	2	Index of start of PIC table
   043.065              PIC.COD	DS	0	Code starts here
U  043.065              	XTEXT	HOSEQU
O  043.065  000 000 000 
                        **	HDOS System Equivalences
                        *
   024.000              S.GRT	EQU	24000A	System area for GRT0
   025.000              S.GRT1	EQU	25000A	System area for GRT1
   026.000              SECSCR	EQU	26000A	System 512 byte scratch area
   030.000              ROMBOOT	EQU	30000A	ROM boot entry
O  043.070  000 000 000 
   040.100              	ORG	40100A	Free Space From PAM-8
   040.100              	DS	8	Jump to system exit
   040.110              D.CON	DS	16	Disk constants
   040.130              SYDD	EQU	*	System disk entry point
   040.130              D.VEC	DS	24*3	System ROM entry vectors
   040.240              D.RAM	DS	31	System ROM Work area
   040.277              S.VAL	DS	38	System values
   040.345              	DS	16	
   040.365              S.SOVR	DS	2	Stack overflow warning
   040.367              	DS	42200A-*	System stack
   001.213              STACKL	EQU	*-S.SOVR	Stack size
   042.200              STACK	EQU	*	LWA+1 system stack
   042.200              USERFWA	EQU	*	User FWA
U  042.200              	XTEXT	EDCON
O  042.200  000 000 000 
                        **	D.CON detailed equivalences
                        *	HOSEQU  must be modified when this table is modified
O  042.203  000 000 000 
A                       	ORG	D.CON
   042.206              D.XITA	DS	2	See system ROM for description
                                                  	HEATH ASM #104.01.00.
                                                   	Page  5

   042.210              D.WRITA	DS	1	
   042.211              D.WRITB	DS	1	
   042.212              D.WRITC	DS	1	
   042.213              D.MAIA	DS	1	
   042.214              D.LPSA	DS	1	
   042.215              D.SDPA	DS	1	
   042.216              D.SDPB	DS	1	
   042.217              D.STSA	DS	1	
   042.220              D.STSB	DS	1	
   042.221              D.WHDS	DS	1	
   042.222              D.WNHA	DS	1	
   042.223              D.WSCA	DS	1	
   042.224              D.ERTS	DS	2	Track and sector of last disk errors
U  042.226              	XTEXT	EDVEC
O  042.226  000 000 000 
O  042.231  000 000 000 
                        **	Jump vectors for ROM code
                        *	See disk rom for addresses
                        *	HOSEQU must be altered when this table is altered
O  042.234  000 000 000 
A                       	ORG	D.VEC
   042.237              D.SYDD	DS	3	JMP   R.SYDD (Must be first)
   042.242              D.MOUNT	DS	3	JMP   R.MOUNT
   042.245              D.XOK	DS	3	JMP   R.XOK
   042.250              D.ABORT	DS	3	JMP   R.ABORT
   042.253              D.XIT	DS	3	JMP   R.XIT
   042.256              D.READ	DS	3	JMP   R.READ
   042.261              D.READR	DS	3	JMP   R.READR
   042.264              D.WRITE	DS	3	JMP   R.WRITE
   042.267              D.CDE	DS	3	JMP   R.CDE
   042.272              D.DTS	DS	3	JMP   R.DTS
   042.275              D.SDT	DS	3	JMP   R.SDT
   042.300              D.MAI	DS	3	JMP   R.MAI
   042.303              D.MAO	DS	3	JMP   R.MAO
   042.306              D.LPS	DS	3	JMP   R.LPS
   042.311              D.RDB	DS	3	JMP   R.RDB
   042.314              D.SDP	DS	3	JMP   R.SDP
   042.317              D.STS	DS	3	JMP   R.STS
   042.322              D.STZ	DS	3	JMP   R.STZ
   042.325              D.UDLY	DS	3	JMP   R.UDLY
   042.330              D.WSC	DS	3	JMP   R.WSC
   042.333              D.WSP	DS	3	JMP   R.WSP
   042.336              D.WNB	DS	3	JMP   R.WNB
   042.341              D.ERRT	DS	3	JMP   R.ERRT
   042.344              D.DLY	DS	3	JMP   R.DLY
U  042.347              	XTEXT	EDRAM
O  042.347  000 000 000 
                        **	EDRAM - disk RAM workarea definition
                        *	Zeroed on boot up
                        *	HOSEQU must be changed i this table is changed
O  042.352  000 000 000 	
A                       	ORG	D.RAM
   042.355              D.TT	DS	1	Target Track (current operation)
   042.356              D.TS	DS	1	Target Sector (current operation)
   042.357              D.DVCTL	DS	1	Device Control byte
   042.360              D.DLYMO	DS	1	Motor on delay count
   042.361              D.DLYHS	DS	1	Head settle delay counter
O  042.362  000 000 000 
                                                  	HEATH ASM #104.01.00.
                                                   	Page  6

   042.365              D.TRKPT	DS	2	Address in D.DRVTB for track number
   042.367              D.VOLPT	DS	2	Address in D.DRVTB for volume number
   042.371              D.DRVTB	DS	2*4	Track number and volume number for 4 drives
   043.001              D.HECNT	DS	1	Hard error count
   043.002              D.SECNT	DS	2	Soft error count
   043.004              D.OECNT	DS	1	Operation error count
O  043.005  000 000 000 
                        *	Global Disk error counters
   043.010              D.ERR	DS	0	Beginning of error block
   043.010              D.E.MDS	DS	1	Missing data sync
   043.011              D.E.HSY	DS	1	Missing reader sync
   043.012              D.E.CHK	DS	1	Data checksum 
   043.013              D.E.HCK	DS	1	Header checksum
   043.014              D.E.VOL	DS	1	Wrong volume number
   043.015              D.E.TRK	DS	1	Bad Track seek
   043.016              D.ERRL	DS	0	Limit of error counters
O  043.016  000 000 000 
                        *	I/O Operation counts
   043.021              D.OPR	DS	2	
   043.023              D.OPW	DS	2	
   043.025              D.RAML	DS	*-D.RAM	
U  045.212              	XTEXT	ESVAL
O  045.212  000 000 000 
                        **	S.VAL  -- System value definitions
                        *	These values are set and maintained by the system
                        *	HOSEQU must be modified when this is modified
O  045.215  000 000 000 
A                       	ORG	S.VAL
   045.220              S.DATE	DS	9	System Date (in ASCII)
   045.231              S.DATC	DS	2	Coded date
   045.233              S.TIME	DS	4	Time from midnight (in Tics)
   045.237              S.HIMEM	DS	2	Hardware high memory address + 1
   045.241              S.SYSM	DS	2	FWA Resident system
   045.243              S.USRM	DS	2	LWA user memory
   045.245              S.OMAX	DS	2	Max overlay size for system	
O  045.247  000 000 000 
O  045.252  000 000 000 
                        **	The following five cells should be modified/read only via the .consl syscall
   000.200              CSL.ECH	EQU	10000000B	Suppress echo
   000.002              CSL.WRP	EQU	00000010B	Wrap lines at width
   000.001              CSL.CHR	EQU	00000001B	Operate in character mode
O  045.255  000 000 000 
   000.000              I.CSLMD	EQU	0	S.CSLMD is first byte	
   045.260              S.CSLMD	DS	1	Console mode
O  045.261  000 000 000 
   000.200              CTP.BKS	EQU	10000000B	Terminal processes backspaces
   000.040              CTP.MLI	EQU	00100000B	Map lower case to upper on input
   000.020              CTP.MLO	EQU	00010000B	Map lower case to upper on output
   000.010              CTP.2SB	EQU	00001000B	Terminal needs two stop bits
   000.002              CTP.BKM	EQU	00000010B	Map Backspace on input to Rubout
   000.001              CTP.TAB	EQU	00000001B	Terminal supports tab characters
O  045.264  000 000 000 
   000.001              I.CONTY	EQU	1	S.CONTY is 2nd byte
AP 000.006              	ERRNZ	*-S.CSLMD-I.CONTY
   045.267              S.CONTY	DS	1	Console type flags
O  045.270  000 000 000 
   000.002              I.CUSOR	EQU	2	S.CUSOR is 3rd byte
UAP000.013              	ERRNZ	*-S.CSLMD-I.CURSOR
                                                  	HEATH ASM #104.01.00.
                                                   	Page  7

O  045.273  000 000 000 
   000.003              I.CONWI	EQU	3	S.CONWI is 4th byte
AP 000.013              	ERRNZ	*-S.CSLMD-I.CONWI
O  045.276  000 000 000 
   045.301              S.CONWI	DS	1	Console width
O  045.302  000 000 000 
   000.001              CO.FLG	EQU	00000001B	CTL-O flag
   000.200              CS.FLG	EQU	10000000B	CTL-S flag
O  045.305  000 000 000 
   000.004              I.CONFL	EQU	4	S.CONFL is 5th byte
AP 000.024              	ERRNZ	*-S.CSLMD-I.CONFL
O  045.310  000 000 000 
   045.313              S.CONFL	DS	1	Console flags
   045.314              S.CAADR	DS	2	Address for abort processing (>256 if valid)
   045.316              S.CCTAB	DS	6	Address for CTL-A, CTL-B, CTL-C processing
U  045.324              	XTEXT	ESINT
O  045.324  000 000 000 
                        **	S.INT - system internal workarea definitions
                        *	These cells are referenced by overlays and main code, and
                        *	therefore must reside in fixed low memory
O  045.327  000 000 000 
UA                      	ORG	S.INT
                        **	Console Status flags
   045.332              S.CDB	DS	1	Console descriptor byte
A                       CDB.H85	EQU	00000000B
   000.001              CDB.H84	EQU	00000001B	=0 If H8-5, =1 if H8-4
   045.333              S.BAUD	DS	2	[0-14] H8-4 baud rate, =0 if H8-5
                        *			[15] = 1 if baud rate => 2 stop bits
O  045.335  000 000 000 
                        **	Table Address Words
   045.340              S.DLINK	DS	2	Address of data in HDOS code
   045.342              S.CFWA	DS	2	FWA channel table
   045.344              S.DFWA	DS	2	FWA device table
   045.346              S.RFWA	DS	2	FWS resident HDOS code
O  045.350  000 000 000 
                        **	Device Driver Delayed load flags
   045.353              S.DDLDA	DS	2	Driver load address (high byte=0 if no load pending)
   045.355              S.DDLEN	DS	2	Code length in bytes
   045.357              S.DDGRP	DS	2	Group number for driver
   045.361              	DS	2	Hold place
                        * S.DDSEC	DS	2	(Obsolete) Sector number for driver
   045.363              S.DDDTA	DS	2	Device's address in DEVLST + DEV.RES
   045.365              S.DDOPC	DS	2	Open Opcode pending
O  045.367  000 000 000 
                        **	Overlay management flags
   000.001              OVL.IN 	EQU	00000001B	In memory
   000.002              OVL.RES	EQU	00000010B	Permanently resident
   000.200              OVL.UCS	EQU	10000000B	User code swapped for overlay
O  045.372  000 000 000 
   045.375              S.OVLFL	DS	1	Overlay flag
   045.376              S.UCSF	DS	2	FWA Swapped user code
   046.000              S.UCSL	DS	2	Length swapped user code
   046.002              S.OVLS	DS	2	Size of overlay code
   046.004              S.OVLE	DS	2	Entry point of overlay code
   046.006              S.SSN	DS	2	Swap area sector number
   046.010              S.OSN	DS	2	Overlay sector number
O  046.012  000 000 000 
                        *	Syscall processing areas
                                                  	HEATH ASM #104.01.00.
                                                   	Page  8

   046.015              S.CACC	DS	1	(ACC) Upon Syscall
   046.016              S.CODE	DS	1	Syscall index in progress
O  046.017  000 000 000 
                        *	Jumps to routines in resident HDOS code
   046.022              S.JUMPS	DS	0	Start of dump vectors
   046.022              S.SDD	DS	3	Jump to stand-in device driver
   046.025              S.FASER	DS	3	Jump to FATSERR (Fatal system error)
   046.030              S.DIREA	DS	3	Jump to DIREAD (Disk file read)
   046.033              S.FCI	DS	3	Jump to Fetch Channel Info
   046.036              S.SCI	DS	3	Jump to Store Channel Info
   046.041              S.MOUNT	DS	1	<> 0 if the system disk is mounted
   046.042              S.DCS	DS	1	Default cluster size - 1
   046.043              	DS	1	Unused
O  046.044  000 000 000 
                        *	Stack value saved for overlay syscalls
   046.047              S.OVSTK	DS	2	Value of SP upon Syscalls using overlay
O  046.051  000 000 000 
                        *	Volume dependent values for SY1:
   046.054              S.S1DIS	DS	2	directory sector
   046.056              S.S1GRT	DS	2	GRT sector
O  046.060  000 000 000 
                        **	Active I/O area
                        *
                        *	The AIO.XXX area contains informaton about the I/OOperation
                        *	currently being performed.  The information is obtained from 
                        *	the channel table and will be restored there when done.
                        *
                        *	Normally the AIO.XXX information would be obtained directly 
                        *	from various system tables via pointer registers.  Since the
                        *	8080 has no good indexed addressing, the data is manually
                        *	copied into the AIO.XXXX cells before processing and 
                        *	backdated after processing.
O  046.063  000 000 000 
   046.066              AIO.VEC	DS	3	Jump instruction
   046.071              AIO.DDA	DS	*-2	Device driver address
   114.160              AIO.FLG	DS	1	Flag byte
   114.161              AIO.GRT	DS	2	Address of group reserv table
   114.163              AIO.SPG	DS	1	sectors per group
   114.164              AIO.CGN	DS	1	Current Group number
   114.165              AIO.CSI	DS	1	current sector index
   114.166              AIO.LGN	DS	1	Last group number
   114.167              AIO.LSI	DS	1	Last sector index
   114.170              AIO.DTA	DS	2	Device Table address
   114.172              AIO.DES	DS	2	directory sector
   114.174              AIO.DEV	DS	2	Device code
   114.176              AIO.UNI	DS	1	Unit number (0-9)
O  114.177  000 000 000 
   114.202              AIO.DIR	DS	DIRELEN	Directory Entry
O  157.116  000 000 000 
   157.121              AIO.CNT	DS	1	Sector count
   157.122              AIO.EOM	DS	1	End of media flag
   157.123              AIO.EOF	DS	1	End of file flag
   157.124              AIO.TFP	DS	2	Temp file pointers
   157.126              AIO.CHA	DS	2	Address of Channel block (IOC.DDA)
O  157.130  000 000 000 
                        ****	Start at page 12
A                       	ORG	30000A
   157.133  303 257 171 	JMP	BOOT	Jump to Boot code
                                                  	HEATH ASM #104.01.00.
                                                   	Page  9

O  157.136  000 000 000 
                        **	Memory Diagnostic
                        *
O  157.141  000 000 000 
A  157.144  041 000 000 	LXI	H, -64
   157.147  071         	DAD	SP	(HL) = End
   157.150  353         	XCHG		(DE) = End + 1
   157.151  041 100 040 	LXI	H,40100A	(HL) = Start
O  157.154  000 000 000 	HLY		Pause for adjustment
O  157.157  000 000 000 
                        *	(HL) = Start
                        *	(DE) = End
O  157.162  000 000 000 
                        *	Zero Test Area
A  157.165  042 076 040 	SHLD	40100A-2
A  157.170  066 000     MEM1	MVI	M,0
   157.172  043         	INX	H
A  157.173  315 132 160 	CALL	$CDEHL
A  157.176  302 170 157 	JNE	MEM1
O  157.201  000 000 000 
                        *	Start testing memory, increment each byte in turn, and compare
                        *	that result to the expected value
O  157.204  000 000 000 
   157.207  006 000     	MVI	B,0	(B) = Expected value
A  157.211  052 076 040 MEM2	LHLD	40100A-2
   157.214  004         	INR	B
O  157.215  000 000 000 
   157.220  064         MEM3	INR	M
   157.221  174         	MOV	A,H	(A) = Value
   157.222  270         	CMP	B
   157.223  312 242 157 	JE	MEM4	Value is ok
O  157.226  000 000 000 
                        *	Have error, (HL) = address of byte in error
O  157.231  000 000 000 	HLT
O  157.234  000 000 000 	NOP
O  157.237  000 000 000 
   157.242  043         MEM4	INX	H
A  157.243  315 132 160 	CALL	$CDEHL
   157.246  302 220 157 	JNE	MEM3	Not at the end of the pass
   157.251  303 211 157 	JMP	MEM2	At end of pass
U  157.254              	XTEXT	COMP
O  157.254  000 000 000 
                        **	$COMP - compare two character strings
                        *	$COMP compares 2 byte strings
                        *
                        *	Entry	(C) = compare count
                        *		(DE) = FWA of string #1
                        *		(HL) = FWA of string #2
                        *	Exit	'Z' Clear, is mismatch
                        *		(C) = length remaining
                        *		(DE) = address of mismatch in string1
                        *		(HL) = address of mismatch in string 2
                        *		'C' Set, have match
                        *		(DE) = (DE) + (OC)
                        *		(HL) = (HL) + (OC)
                        *	Uses A,F,C,D,E,H,L
O  157.257  000 000 000 
   157.262  032         $COMP	LDAX	D
                                                  	HEATH ASM #104.01.00.
                                                   	Page 10

   157.263  274         	CMP	H	Compare
   157.264  300         	RNE		No match
   157.265  023         	INX	D
   157.266  043         	INX	H
   157.267  015         	DCR	C
   157.270  302 262 157 	JNZ	$COMP	Try some more
   157.273  311         	RET		Have match
U  157.274              	XTEXT	DADA
O  157.274  000 000 000 
                        **	$DADA - perform (H,L) = (H,L) + (O,A)
                        *
                        *	Entry	(H,L) = before value
                        *		(A) = before value
                        *	
                        *	Exit	(H,L) = (H,L) + (O,A)
                        *		'C' set if overflow
                        *	Uses F,H,L
   157.277  325         $DADA	PUSH	D
   157.300  137         	MOV	E,A
A  157.301  026 000     	MVI	D,0
   157.303  031         	DAD	D
   157.304  321         	POP	D
   157.305  311         	RET		Exit
U  157.306              	XTEXT	DADA2
O  157.306  000 000 000 
                        **	$DADA.  -  add (O,A) to (H,L)
                        *
                        *	Entry	None
                        *	Exit	(HL) = (HL) + (OA)
                        *	Uses	A,F,H,L
O  157.311  000 000 000 
   157.314  205         $DADA.	ADD	L
   157.315  157         	MOV	L,A
O  157.316  000 000 000 	RNC
   157.321  044         	INR	H
O  157.322  000 000 000 	RET
U  157.325              	XTEXT	DU66
O  157.325  000 000 000 
                        **	$DU66 unsigned 16/16 divide
                        *
                        *	(HL) = (BC)/(DE)
                        *
                        *	Entry	(BC), (DE) preset
                        *	Exit	(HL) = result
O  157.330  000 000 000 		(DE) = remainder
                        *	Uses 	All
O  157.333  000 000 000 
   157.336  172         $DU66	MOV	A,D	Two's complement (DE)
O  157.337  000 000 000 	CMA
   157.342  127         	MOV	D,A
   157.343  173         	MOV	A,E
O  157.344  000 000 000 	CMA
   157.347  137         	MOV	E,A
   157.350  023         	INX	D
   157.351  172         	MOV	A,D
   157.352  263         	ORA	E
U  157.353  312 000 000 	JZ	DU665	If divide by zero
   157.356  257         	XRA	A
                                                  	HEATH ASM #104.01.00.
                                                   	Page 11

O  157.357  000 000 000 
                        *	Shift (DE) left until
                        *	1)  DE > BL
                        *	2)  Overflow
O  157.362  000 000 000 
   157.365  142         DU661	MOV	H,D
   157.366  153         	MOV	L,E
   157.367  011         	DAD	B
   157.370  322 020 160 	JNC	DU662	Is too large
   157.373  074         	INR	A	Count shift
   157.374  142         	MOV	H,D
   157.375  153         	MOV	L,E
   157.376  051         	DAD	H
   157.377  353         	XCHG		(DE) = (DE) *2
   160.000  332 365 157 	JC	DU661	If no overflow
O  160.003  000 000 000 
                        *	(DE) overflowed, put it back
O  160.006  000 000 000 	XCHG
   160.011  075         	DCR	A	Remove extra count
O  160.012  000 000 000 
                        *	Ready to start subtracting, (A) = loop count
O  160.015  000 000 000 
   160.020  140         DU662	MOV	H,B	(H,L) = working value
   160.021  151         	MOV	L,C
   160.022  001 000 000 	LXI	B,0	(BC) = result
   160.025  365         DU663	PUSH	PSW	Save (A)
   160.026  031         	DAD	D
   160.027  332 040 160 	JC	DU664	If subtract ok
   160.032  175         	MOV	A,L	Add back in
   160.033  223         	SUB	E
   160.034  157         	MOV	L,A
   160.035  174         	MOV	A,H
   160.036  232         	SBB	D
   160.037  147         	MOV	H,A
   160.040  171         DU664	MOV	A,C
O  160.041  000 000 000 	RAL
   160.044  117         	MOV	C,A
   160.045  170         	MOV	A,B
O  160.046  000 000 000 	RAL
   160.051  107         	MOV	B,A
O  160.052  000 000 000 
                        *	Right shift (DE)
O  160.055  000 000 000 	STC
   160.060  172         	MOV	A,D
O  160.061  000 000 000 	RAR
   160.064  127         	MOV	D,A
   160.065  173         	MOV	A,E
O  160.066  000 000 000 	RAR
   160.071  137         	MOV	E,A
   160.072  361         	POP	PSW
   160.073  075         	DCR	A
   160.074  362 025 160 	JP	DU663	If not done
O  160.077  000 000 000 	DU665	XCHG	(D,E) = remainder
   160.102  140         	MOV	H,B	(HL) = result
   160.103  151         	MOV	L,C
O  160.104  000 000 000 	RET
U  160.107              	XTEXT	HLIHL
O  160.107  000 000 000 
                                                  	HEATH ASM #104.01.00.
                                                   	Page 12

                        **	$HLIHL	Load HL indirect through HL
                        *
                        *	(HL) = ((HL))
                        *
                        *	Entry 	None
                        *	Exit	None
                        *	Uses	A,H,L
O  160.112  000 000 000 
   160.115  176         $HLIHL	MOV	A,M
   160.116  043         	INX	H
   160.117  145         	MOV	H,L
   160.120  157         	MOV	L,A
O  160.121  000 000 000 	RET
U  160.124              	XTEXT	CDEHL
O  160.124  000 000 000 
                        **	$CDEHL  - compare (DE) to (HL)
                        *	$CDEHL compare (DE) to (HL) for equality
                        *
                        *	Entry	None
                        *	Exit	'Z' set if (DE) = (HL)
                        *	Uses	A, F
O  160.127  000 000 000 
   160.132  173         $CDEHL	MOV	A,E
   160.133  255         	XRA	L
O  160.134  000 000 000 	RNX		If different
   160.137  172         	MOV	A,D
   160.140  254         	XRA	H
O  160.141  000 000 000 	RET
U  160.144              	XTEXT	CHL	Complement (HL)
O  160.144  000 000 000 	
                        **	$CHL - complement (HL)
                        *	(HL) = - (HL)	Two's complement
                        *
                        *	Entry	None
                        *	Exit	None
                        *	Uses	A,F,H,L
O  160.147  000 000 000 
   160.152  174         $CHL	MOV	A,H
O  160.153  000 000 000 	CMA
   160.156  147         	MOV	H,A
   160.157  175         	MOV	A,L
O  160.160  000 000 000 	CMA
   160.163  157         	MOV	L,A
   160.164  043         	INX	H
O  160.165  000 000 000 	RET
U  160.170              	XTEXT	INDL	Indexed load
O  160.170  000 000 000 	
                        **	$INDL	Indexed load
                        *	$INDL loads DE with 2 bytes at (HL) + displacement
                        *	This acts as an indexed full word load
                        *
                        *	(DE) = ((HL) + displacement )
                        *
                        *	Entry	((RET)) = displacement (full word)
                        *		(HL) = table address
                        *	Exit	to (RET + 2)
                        *	Uses	A,F, D, E
O  160.173  000 000 000 
                                                  	HEATH ASM #104.01.00.
                                                   	Page 13

   160.176  343         $INDL	XTHL		(HL) = RET, ((SP)) = Table address
   160.177  136         	MOV	E,M
   160.200  043         	INX	H
   160.201  126         	MOV	D,M	(DE) = displacement
O  160.202  000 000 000 	
   160.205  043         	INX	H
   160.206  343         	XTHL		((SP)) = RET, (HL) = table address
   160.207  353         	XCHG		(DE) = Table address, (HL) = displacement
   160.210  031         	DAD	D	(HL) = target address
   160.211  176         	MOV	A,M	
   160.212  043         	INX	H
   160.213  146         	MOV	H,M
   160.214  157         	MOV	L,A	(HL) = ((HL))
   160.215  353         	XCHG		(DE) = value, (HL) = table address
O  160.216  000 000 000 	RET
O  160.221  000 000 000 
                        **	$MOVE - move data
                        *	$MOVE moves a block of bytes to a new memory address.
                        *	If the move is to a lower address, the bytes are moved from 
                        *	First to Last.
                        *
                        *	If the move is to a higher adres, the bytes are moved from
                        *	Last to First.
                        *
                        *	This is done so that an overlapped move will not 'ripple'
                        *
                        *	Entry	(BC) = count
                        *		(DE) = From
                        *		(HL) = To
                        *	Exit	Moved
                        *		(DE) = address of next 'From' byte
                        *		(HL) = address of next 'To' byte
                        *		'C' Clear
                        *	Uses	All
O  160.224  000 000 000 
A                       $MOVE	EQU	*
   160.227  170         	MOV	A,B
   160.230  261         	ORA	C
   160.231  310         	RZ		Nothing to move
   160.232  175         	MOV	A,L	Compare 'From' to 'To'
   160.233  223         	SUB	E	
   160.234  174         	MOV	A,H
   160.235  232         	SBB	D
   160.236  332 301 160 	JC	MOV2	Is move down (to lower addresses)
O  160.241  000 000 000 	
                        *	is move up (to higher addresses)
   160.244  013         	DCX	B
   160.245  011         	DAD	B	(HL) = 'To' LWA
   160.246  345         	PUSH	H	Save 'To' limit
O  160.247  000 000 000 	XCHG
   160.252  011         	DAD	B	(HL) = 'From' LWA
   160.253  345         	PUSH	H	Save 'From' limit
O  160.254  000 000 000 	
   160.257  176         MOV1	MOV	A,M	Move byte
   160.260  022         	STAX	D
   160.261  033         	DCX	D	Increment 'To' addresss
   160.262  053         	DCX	H	Increment 'from' address
   160.263  013         	DCX	B	Decrement count
                                                  	HEATH ASM #104.01.00.
                                                   	Page 14

   160.264  170         	MOV	A,B
   160.265  247         	ANA	A
   160.266  362 257 160 	JP	MOV1	More to do
   160.271  321         	POP	D	(DE) = 'From' limit
   160.272  341         	POP	H	(HL) = 'To' limit
   160.273  023         	INX	D
   160.274  043         	INX	H
   160.275  311         	RET		Done!
O  160.276  000 000 000 	
                        *	is move down to lower address
   160.301  032         MOV2	LDAX	D	Move byte
   160.302  167         	MOV	M,A
   160.303  043         	INX H		Increment 'From'
   160.304  023         	INX	D	Increment 'To'
   160.305  013         	DCX	B	Decrement count
   160.306  170         	MOV	A,B
   160.307  261         	ORA	C
   160.310  302 301 160 	JNZ	MOV2	If not done, do it again
   160.313  311         	RET		Otherwise done
U  160.314              	XTEXT	MU10
O  160.314  000 000 000 
                        ** 	$MU10 - multiply unsigned 16 bit quantity by 10
                        *
                        *	(HL) = (DE) * 10
                        *
                        *	Entry	(DE) = multiplier
                        *	Exit	'C' clear if ok
                        *		(HL) = product
                        *		'C' set if error
                        *	Uses	D,E,H,L,F
O  160.317  000 000 000 
   160.322  353         $MU10	XCHG		(HL) = multiplier
   160.323  051         	DAD	H	(HL) = X * 2
O  160.324  000 000 000 	RC
   160.327  124         	MOV	D,H
   160.330  135         	MOV	E,L
   160.331  051         	DAD	H	(HL) = X*4
O  160.332  000 000 000 	RC
   160.335  051         	DAD	H	(HL) = X*8
   160.336  330         	RC	
   160.337  031         	DAD	D	(HL) = X*10
O  160.340  000 000 000 	RET
U  160.343              	XTEXT	MU66
O  160.343  000 000 000 	
                        ** 	$MU66 - multiply unsigned 16 x 16
                        *
                        *	Entry	(BC) = multiplicand
                        *		(DE) = Multiplier
                        *	Exit	(HL) = result
                        *		'Z' set if not overflow
                        *	Uses	All
O  160.346  000 000 000 
   160.351  257         $MU66	XRA	A
   160.352  365         	PUSH	PSW	Save overflow status
A  160.353  041 000 000 	LXI	H,0
O  160.356  000 000 000 	
   160.361  170         MU661	MOV	A,B
O  160.362  000 000 000 	RAR
                                                  	HEATH ASM #104.01.00.
                                                   	Page 15

   160.365  107         	MOV	B,A
   160.366  171         	MOV	A,C
O  160.367  000 000 000 	RAR
   160.372  117         	MOV	C,A
   160.373  322 005 161 	JNC	MU662	If bit clear
   160.376  031         	DAD	D
   160.377  322 005 161 	JNC	MU662	If not overflow
   161.002  361         	POP	PSW
   161.003  074         	INR	A
   161.004  365         	PUSH	PSW
   161.005  170         MU662	MOV	A,B
   161.006  261         	ORA	C	See if multiplier = 0
   161.007  312 035 161 	JZ	MU663	IF mulitplier =0, we're done
O  161.012  000 000 000 	XCHG
   161.015  051         	DAD	H	(DE) = (DE) * 2
O  161.016  000 000 000 	XCHG
   161.021  322 361 160 	JNC	MU661	If not overflow
   161.024  361         	POP	PSW
   161.025  074         	INR	A
   161.026  365         	PUSH	PSW	Flag overflow
   161.027  303 361 160 	JMP	MU661	Process next bit
O  161.032  000 000 000 	
   161.035  361         MU663	POP	PSW	(A,F) = overflow status
O  161.036  000 000 000 	RET
U  161.041              	XTEXT	MU86
O  161.041  000 000 000 	
                        **	$MU86 - multiply 8 x 16 unsigned
                        *	$MU86 multiplies a 16 bit value by an 8 bit value
                        *
                        *
                        *	Entry	(A) = multiplier
                        *		(DE) = multiplicand
                        *	Exit	(HL) = result
                        *		'Z' set if not overflow
                        *	Uses	A,F,H,L
O  161.044  000 000 000 
   161.047  041 000 000 $MU86	LXI	H,0	(HL) = result accumulator
   161.052  305         	PUSH	B
   161.053  104         	MOV	B,H	(B) = overflow flag
   161.054  267         MU860	ORA	A	Clear carry
O  161.055  000 000 000 MU861	RAR
   161.060  322 070 161 	JNC	MU862	If not to add
   161.063  031         	DAD	D
   161.064  322 070 161 	JNC	MU862	Not overflow
   161.067  004         	INR	B
   161.070  267         MU862	ORA	A
   161.071  312 113 161 	JZ	MU863	If done
   161.074  353         	XCHG	
   161.075  051         	DAD	H	
O  161.076  000 000 000 	XCHG
U  161.101  322 000 000 	JNC	MU861	Loop if not overflow
   161.104  004         	INR	B
A  161.105  303 054 161 	JMP	MU860
O  161.110  000 000 000 	
   161.113  260         MU863	ORA	B	Set *Z* flag if not overflow
   161.114  301         	POP	B	Restore (BC)
O  161.115  000 000 000 	RET
U  161.120              	XTEXT	SAVALL
                                                  	HEATH ASM #104.01.00.
                                                   	Page 16

O  161.120  000 000 000 	
                        **	$RSTALL - restore all registers
                        *
                        *	$RSTALL restores all registers off the stack and 
                        *	returns to the previous caller
                        *
                        *	Entry	(SP) = PSW
                        *		(SP+2) = BC
                        *		(SP+4) = DE
                        *		(SP+6) = HL
                        *		(SP+8) = Return address
                        *	Exit	To *Return*, registers restored
                        *	Uses	All
O  161.123  000 000 000 
   161.126  361         $RSTALL	POP	PSW
   161.127  301         	POP	B
   161.130  321         	POP	D
   161.131  341         	POP	H
O  161.132  000 000 000 	RET
O  161.135  000 000 000 	
                        **	$SAVALL - saves all registers on stack
                        *
                        *	Entry	None
                        *	Exit	(SP) = PSW
                        *		(SP+2) = BC
                        *		(SP+4) = DE
                        *		(SP+6) = HL
                        *		(SP+8) = Return address
                        *	Uses	H,L
O  161.140  000 000 000 
   161.143  343         $SAVALL	XTHL		Push H, (HL) = return address
   161.144  325         	PUSH	D
   161.145  305         	PUSH	B
   161.146  365         	PUSH	PSW
   161.147  351         	PCHL		Return to caller
U  161.150              	XTEXT	TJMP
O  161.150  000 000 000 	
                        **	$TJMP - Table jump
                        *	Useage:
                        *	CALL	$TJMP	(A) = index
                        *	DW	ADDR1	Index = 0
                        *
                        *
                        *	DW	ADDRN	Index = N-1
                        *
                        *	Entry	(A) = Index
                        *	Exit	To Processor
                        *		(A) = Index * 2
                        *	Uses	A,F
O  161.153  000 000 000 
   161.156  007         $TJMP	RLC		(A) = Index *2
O  161.157  000 000 000 
A                       $TJMP.	EQU	*
   161.162  343         	XTHL		(HL) = Table Address
   161.163  365         	PUSH	PSW	Save Index * 2
A  161.164  315 277 157 	CALL	$DADA
   161.167  176         	MOV	A,M
   161.170  043         	INX	H
                                                  	HEATH ASM #104.01.00.
                                                   	Page 17

   161.171  146         	MOV	H,M
   161.172  157         	MOV	L,A
   161.173  361         	POP	PSW	(A) = index * 2
   161.174  343         	XTHL		Address on stack
   161.175  311         	RET		Jump to processor
U  161.176              	XTEXT	TBRA
O  161.176  000 000 000 	
                        **	$TBRA - branch relative through table
                        *
                        *	$TBRA uses the supplied index to select a byte from the
                        *	Jump table.  The contents of this byte are added to the 
                        *	address of the byte, yielding the processor address.
                        *
                        *	CALL 	$TBRA
                        *	DB	LAB1 - *		Index = 0 for Lab1
                        *	DB	LAB2 - *		Index = 1 for Lab2
                        *	DB	LABN - *		Index = N-1 for LabN
                        *
                        *	Entry	(A) = Index
                        *		(RET) = Table FWA
                        *	Exit	to computed address
                        *	Uses	F,H,L
O  161.201  000 000 000 
A                       $TBRA	EQU	*
   161.204  343         	XTHL		(HL) = table address
   161.205  325         	PUSH	D
   161.206  137         	MOV	E,A
A  161.207  026 000     	MVI	D,0
   161.211  031         	DAD	D	(HL) = address of element
   161.212  136         	MOV	E,M	
   161.213  031         	DAD	D	(HL) = processor address
   161.214  321         	POP	D
O  161.215  000 000 000 	XTHL
O  161.220  000 000 000 	RET
O  161.223  000 000 000 	
                        **	$TBLS - table search
                        *
                        *	Table format
                        *	DB	Key1, Val1
                        *	.	.
                        *	.	.
                        *	DB	KeyN, ValN
                        *	DB	0
                        *
                        *	Entry	(A) = pattern
                        *		(H,L) = table FWA
                        *	Exit	(A) = pattern if found
                        *		'Z' set if found
                        *	Uses	a, F, H, L
O  161.226  000 000 000 
   161.231  305         $TBLS	PUSH	B
   161.232  107         	MOV	B,A
   161.233  176         $TBL1	MOV	A,M	(A) = character
   161.234  270         	CMP	B
   161.235  312 261 161 	JZ	$TBL2	If match
   161.240  247         	ANA	A
   161.241  043         	INX	H
   161.242  043         	INX	H	Skip past
                                                  	HEATH ASM #104.01.00.
                                                   	Page 18

   161.243  302 233 161 	JNZ	$TBL1	If not end of table
   161.246  053         	DCX	H
   161.247  053         	DCX	H
   161.250  264         	ORA	H	Clear 'Z'
   161.251  076 000     	MVI	A,0	Set (A) = 0 for old users
O  161.253  000 000 000 
                        *	DONE
O  161.256  000 000 000 
   161.261  301         $TBL2	POP	B
   161.262  043         	INX	H
O  161.263  000 000 000 	RET
O  161.266  000 000 000 	
                        **	$TYPTX - Type text
                        *	$TYPTX is called to type a block of text on the system console.
                        *
                        *	Embedded zero bytes indicate a carriage return line line feed.
                        *	A byte with the 200Q bit set is the last byte in the message.
                        *
                        *	Entry	(RET) = Text
                        *	Exit	To (RET + Length)
                        *	Uses	A,F
O  161.271  000 000 000 
   161.274  343         $TYPTX	XTHL		(HL) = text address
   161.275  315 311 161 	CALL	$TYPTX.	Type it
O  161.300  000 000 000 	XTHL
O  161.303  000 000 000 	RET
O  161.306  000 000 000 	
   161.311  176         $TYPTX.	MOV	A,M
A  161.312  346 177     	ANI	177Q
A  161.314  377 000     	DB	SYSCALL, .SCOUT
   161.316  276         	CMP 	M
   161.317  043         	INX	H
   161.320  312 311 161 	JE	$TYPTX.	More to go
O  161.323  000 000 000 	RET
U  161.326              	XTEXT	UDD
O  161.326  000 000 000 
                        **	$UDD - unpack decimal digits
                        *
                        *	UDD converts a 16 bit value into a specified number of
                        *	decimal digits.  The result is zero filled.
                        *
                        *	Entry	(B,C) = Address value
                        *		(A) = Digit count
                        *		(H,L) = memory address
                        *	Exit	(HL) = (HL) + (A)
                        *	USes	All
O  161.331  000 000 000 
A                       $UDD	EQU	*
A  161.334  315 277 157 	CALL	$DADA
   161.337  345         	PUSH	H	Save final (HL) value
O  161.340  000 000 000 	
   161.343  365         UDD1	PUSH	PSW
   161.344  345         	PUSH	H
A  161.345  021 012 000 	LXI	D,10
   161.350  315 336 157 	CALL	$DU66	(HL) = value/10
   161.353  345         	PUSH	H
   161.354  301         	POP	B	(B,C) = remainder
   161.355  341         	POP	H
                                                  	HEATH ASM #104.01.00.
                                                   	Page 19

A  161.356  076 060     	MVI	A,'0'
   161.360  203         	ADD	E	Add remainder
   161.361  053         	DCX	H
   161.362  167         	MOV	M,A	Store digit
   161.363  361         	POP	PSW
   161.364  075         	DCR	A
   161.365  302 343 161 	JNZ	UDD1	If more to go
   161.370  341         	POP	H	Restore H
O  161.371  000 000 000 	RET
U  161.374              	XTEXT 	ZERO
O  161.374  000 000 000 
                        **	$ZERO - zero memory
                        *
                        *	zero a block of memory
                        *
                        *	Entry	(HL) = address
                        *		(B) = count
                        *	Exit	(A) = 0
                        *	Uses	A,B,F,H,L
O  161.377  000 000 000 
   162.002  257         $ZERO	XRA	A
   162.003  167         ZRO1	MOV	M,A
   162.004  043         	INX	H
   162.005  005         	DCR	B
   162.006  302 003 162 	JNZ	ZRO1	If more to do
O  162.011  000 000 000 	RET
O  162.014  000 000 000 
                        ****	Start at page 25
                        **	$WDR -write disable RAM
                        *	is called to disable the writability of the H17 controller RAM area
                        *	Entry	None
                        *	Exit	None
                        *	Uses	None
O  162.017  000 000 000 
   162.022  365         $WDR	PUSH	PSW
O  162.023  000 000 000 	DI
U  162.026  072 000 000 	LDA	D,DVCTL
A  162.031  346 177     	ANI	377Q-DF.WR
U  162.033  062 000 000 $WDR1	STA	D, DVCTL
U  162.036  323 000     	OUT	DP,DC
O  162.040  000 000 000 	EI
   162.043  361         	POP	PSW
O  162.044  000 000 000 	RET
O  162.047  000 000 000 	
                        **	$WER -write ensable RAM
                        *	is called to enable the writability of the H17 controller RAM area
                        *	Entry	None
                        *	Exit	None
                        *	Uses	None
O  162.052  000 000 000 
   162.055  365         $WER	PUSH	PSW
O  162.056  000 000 000 	DI
U  162.061  072 000 000 	LDA	D,DVCTL
U  162.064  366 000     	ORI	DF, WR
A  162.066  303 033 162 	JMP	$WDR1
O  162.071  000 000 000 	
                        **	D.DISK - Device driver read code
                        *
                                                  	HEATH ASM #104.01.00.
                                                   	Page 20

                        *	Entry	(BC) = count (in sectors)
                        *		(DE) = address
                        *		(HL) = sector
                        *	Exit	'C' clear if OK, exit to caller
                        *		'C' set if error
                        *		To S.FASER (Fatal/System Error) if Unit 0
                        *		To caller if other unit
                        *		(A) = Error code
                        *	Uses	<not given in source code listing>
O  162.074  000 000 000 
AV 162.077  076 044     DWRITE	MVI	A,DC.WRI
   162.101  376         	DB	MI.CPI	Skip next
   162.102  257         DREAD	XRA	A	Set read code
AP 043.043              	ERRNZ	DC.REA
   162.103  315 130 040 	CALL	SYDD	Call device driver
   162.106  320         	RNC		If OK
   162.107  365         	PUSH	PSW	Save code
A  162.110  072 176 114 	LDA	AIO.UNI
   162.113  247         	ANA	A
   162.114  314 025 046 	CZ	S.FASER	Is SY0:
   162.117  361         	POP	PSW
   162.120  311         	RET		Return with bad news
O  162.121  000 000 000 	
                        **	SREAD - read from system disk
                        *
                        *	Entry	(BC) = count (in sectors)
                        *		(DE) = address
                        *		(HL) = sector
                        *	Exit	To Caller if OK
                        *		To S.FASER (Fatal system error) IF error
                        *	Uses	<not noted>
O  162.124  000 000 000 
A  162.127  072 176 114 SREAD	LDA	AIO.UNI
   162.132  365         	PUSH	PSW	Save current unit
   162.133  257         	XRA	A
AP 043.043              	ERRNZ	DC.REA
A  162.134  062 176 114 	STA	AIO.UNI
A  162.137  315 130 040 SREAD1	CALL	SYDD
   162.142  334 025 046 	CC	S.FASER	Read error
   162.145  361         	POP	PSW
A  162.146  062 176 114 	STA	AIO.UNI
O  162.151  000 000 000 	RET
O  162.154  000 000 000 	
                        **	Constant zeros
A  162.157  000 000 000 ZEROS	DB	0,0,0,0,0,0,0,0
O  162.167  000 000 000 
                        **	SWRITE - write to system disk
                        *
                        *	Entry	(BC) = count (in sectors)
                        *		(DE) = address
                        *		(HL) = sector
                        *	Exit	To Caller if OK
                        *		To S.FASER (Fatal system error) IF error
                        *	Uses	<not noted>
O  162.172  000 000 000 
A  162.175  072 176 114 SWRITE	LDA	AIO.UNI
   162.200  365         	PUSH	PSW	Save old unit #
   162.201  257         	XRA	A
                                                  	HEATH ASM #104.01.00.
                                                   	Page 21

   162.202  062 176 114 	STA	AIO.UNI	Set system unit
AP 043.043              	ERRNZ	DC.WRI-1
   162.205  074         	INR	A	(A) = DC.WRI
A  162.206  303 137 162 	JMP	SREAD1
O  162.211  000 000 000 	
                        **	ERR.FNO - Error: File not open
V  162.214  076 010     ERR.FNO	MVI	A,EC.FNO	File not open
O  162.216  000 000 000 	STC
   162.221  311         	RET		Error code
O  162.222  000 000 000 	
                        **	ERR.ILR - Error - Illegal request
O  162.225  000 000 000 
V  162.230  076 011     ERR.ILR	MVI	A,EC.ILR	Illegal request
O  162.232  000 000 000 	STC
O  162.235  000 000 000 	RET
O  162.240  000 000 000 	
                        **	CFF - Chain free block to file
                        *
                        *	CFF unchains a free block from the free list and chains 
                        *	it to the end of the active file
                        *
                        *	Entry	(HL) = address in group table of the group in question
                        *		(E) = index of previous group inlist
                        *		AIO.XXX setup
                        *	Exit	AIO.LGN = (L) (at entry)
                        *		AIO.LSI = 0
                        *	Uses 	A,F,D,H,L
O  162.243  000 000 000 
   162.246  176         CFF	MOV	A,M		(A) = next free
   162.247  066 000     	MVI	M,0		New block is end of chain for file
   162.251  125         	MOV	D,L		(D) = new index
   162.252  153         	MOV	L,E		(HL) = address of previous block
   162.253  167         	MOV	M,A		Unchain from free chain
   162.254  072 166 114 	LDA	AIO.LGN		(A) = last group number
   162.257  157         	MOV	L,A		(HL) = address of file last group
   162.260  162         	MOV	M,D		Link to new last block
A  162.261  041 166 114 	LXI	H,AIO.LGN
   162.264  162         	MOV	M,D		Set new LGN
A  000.000              	ERRNZ	AIO.LSI-AIO.LGN-1
   162.265  043         	INX	H
   162.266  066 000     	MVI	M,0		Clear LSI
O  162.270  000 000 000 	RET
O  162.273  000 000 000 
                        **	DCA - determine contiguous area
                        *
                        *	DCA is called to find how many of the sectors which are to be
                        *	read are continguous
                        *
                        *	ENTRY	(B) = sectors desired
                        *		AIO.xxx setup
                        *	EXIT	(B) = sectors - AIO.CNT
                        *		AIO.CNT = sectors which are continuous
                        *		AIO.EOF = EC.EOF * 2 + 1 if EOF
                        *		AIO.TFP = setup with group and index of start of area
                        *	USES	All
O  162.276  000 000 000 
   162.301  315 155 163 DCA1	CALL FFL		Follow Forward Link
O  162.304  000 000 000 
                                                  	HEATH ASM #104.01.00.
                                                   	Page 22

   162.307  052 164 114 DCA	LHLD	AIO.CGN	(H) = current GP #, (L) = current sector index
A  000.000              	ERRNZ	AIO.CSI-AIO.CGN-1
   162.312  042 124 157 	SHLD	AIO.TFP	Temp file ptr
   162.315  315 362 164 	CALL	TFE	Test for EOF
   162.320  062 123 157 	STA	AIO.EOF	Set flag
   162.323  062 121 157 	STA	AIO.CNT	Set CNT = 0 if EOF
   162.326  310         	RE		Is EOF
   162.327  072 165 114 	LDA	AIO.CSI	(A) = current sector index
   162.332  147         	MOV	H,A
A  162.333  072 163 114 	LDA	AIO.SPG
   162.336  274         	CMP	H	See if group exhausted
   162.337  312 301 162 	JE	DCA1	Was pointing at end of group
                        * 	See if more needed
   162.342  170         DCA2	MOV	A,B
   162.343  247         	ANA	A
   162.344  310         	RZ		No more sectors to check
                        *	See how many sectors are left in this group
   162.345  052 166 114 	LHLD	AIO.LGN	(L) = AIO.LGN, (H) = AIO.LSI
A  000.000              	ERRNZ	AIO.LSI-AIO.LGN-1
A  162.350  072 164 114 	LDA	AIO.CGN
   162.353  275         	CMP	L	See if we are pointed at last group
   162.354  312 362 162 	JE	DCA3	We are pointed at last group
   162.357  052 162 114 	LHLD	AIO.SPG-1	(H) = AIO.SPG
   162.362  365         DCA3	PUSH	PSW	Save status
   162.363  072 165 114 	LDA	AIO.CSI	(A) = current sector index
   162.366  224         	SUB	H	(A) = - sectors left in group
O  162.367  000 000 000 	CMA
   162.372  074         	INR	A	(A) = + sectors left in group
   162.373  270         	CMP	B
   162.374  332 000 163 	JC	DCA4	Need more
   162.377  170         	MOV	A,B	Don't take more than we need
   163.000  117         DCA4	MOV	C,A	(C) = amount to take
A  163.001  041 165 114 	LXI	H,AIO.CSI
   163.004  206         	ADD	M	Update CSI to indicate number to be read
   163.005  167         	MOV	M,A
   163.006  171         	MOV	A,C	(A) = number to be read
A  163.007  041 121 157 	LXI	H,AIO.CNT
   163.012  206         	ADD	M	Add to count
   163.013  167         	MOV	M,A
   163.014  170         	MOV	A,B	(A) = amount needed
   163.015  221         	SUB	C
   163.016  107         	MOV	B,A
   163.017  361         	POP	PSW
   163.020  310         	RE		Was on last track; done
   163.021  170         	MOV	A,B
   163.022  247         	ANA	A
   163.023  310         	RZ		No more needed, done
O  163.024  000 000 000 	
                        *	Used up this block, link to next
                        *	If not contiguous, stop here
O  163.027  000 000 000 
A  163.032  072 164 114 	LDA	AIO.CGN
   163.035  074         	INR	A
   163.036  365         	PUSH	PSW	Save next contiguous block #
   163.037  315 155 163 	CALL	FFL	Follow file link
   163.042  361         	POP	PSW
   163.043  275         	CMP	L
   163.044  312 342 162 	JE	DCA2	Got it, was contiguous
                                                  	HEATH ASM #104.01.00.
                                                   	Page 23

   163.047  311         	RET		STOP Here
O  163.050  000 000 000 	
                        **	FFB - find free block
                        *
                        *	FFB is called to locate a free block in the GRT's free chain
                        *
                        *	FFB will attempt to get a 'preferred block', if possible.
                        *	If the preferred block is not available, FFB will (optionally)
                        *	do the best he can: start a virgin cluster.  If possible, then
                        *	just settle for anything
                        *
                        *	ENTRY	(D) = preferred block number (0 if none)
                        *		(C) = preferred flag <= 0, will take something else
                        *			      <> 0, must have preferred block or nothing
                        *	EXIT	'C' set, EOM on device
                        *		'C' clear, not EOM
                        *		'Z' clear, couldn't get preferred block (only if (C)<>0 on Entry)
                        *		'Z' set, got a block (preferred or not)
                        *		(HL) = address of block in GRT table
                        *		(E) = index of free block before the found one
                        *	USES	A,F,E,H,L
O  163.053  000 000 000 
A  163.056  052 161 114 FFB	LHLD	AIO.GRT
   163.061  176         	MOV	A,M	(A) = first free block
   163.062  247         	ANA	A
   163.063  067         	STC		Assume EOM
   163.064  310         	RZ		End of media
                        *	Not end of media, try to find the contiguous block in the free list
O  163.065  000 000 000 
   163.070  135         	MOV	E,L	(E) = index of previous byte
   163.071  054         	INR	L
   163.072  167         	MOV	M,A	Flag change in GRT
   163.073  157         FFB4	MOV	L,A	(HL) = address of next byte in free chain
   163.074  272         	CMP	D
   163.075  310         	RE		Got the one we need
   163.076  322 115 163 	JNC	FFB5	Gone too far
   163.101  135         	MOV	E,L	Save this block index
   163.102  176         	MOV	A,M
   163.103  247         	ANA	A
A  163.104  302 073 163 	JNZ	FFB4
O  163.107  000 000 000 	
                        *	Couldn't find contiguous block. This means a break in
                        *	Continuity.  If we have anything, return with it. If we 
                        *	have nothing yet, try to find a virgin cluster.
O  163.112  000 000 000 
   163.115  171         FFB5	MOV	A,C
   163.116  247         	ANA	A
   163.117  300         	RNZ		Must NOT continue
   163.120  157         	MOV	L,A	(HL) = (AIO.GRT)
   163.121  135         FFB6	MOV	E,L	(E) = index of previous node
   163.122  156         	MOV	L,M	Link forward
A  163.123  072 105 157 	LDA	AIO.DIR+DIR.CLU
   163.126  245         	ANA	L	See if start of cluster
   163.127  310         	RZ		Got virgin cluster
   163.130  176         	MOV	A,M
   163.131  247         	ANA	A
   163.132  302 121 163 	JNZ	FFB6	Try again
O  163.135  000 000 000 	
                                                  	HEATH ASM #104.01.00.
                                                   	Page 24

                        *	Can't find virgin cluster, will take whatever we can get
O  163.140  000 000 000 
   163.143  157         	MOV	L,A
   163.144  135         	MOV	E,L	(E) = index of previous mode
   163.145  156         	MOV	L,M	(HL) = address of first free block byte
   163.146  311         	RET		Return with 'Z' : got one
O  163.147  000 000 000 	
                        **	FFL - follow forward link
                        *
                        *	FFL links AIO.CGN to the next group
                        *
                        *	ENTRY	None
                        *	EXIT	AIO.CGN = Link(AIO.CGN)
                        *		AIO.CSI = 0
                        *		(L) = AIO.CGN
                        *	USES	A,F,H,L
O  163.152  000 000 000 
A  163.155  052 161 114 FFL	LHLD	AIO.GRT
A  163.160  072 164 114 	LDA	AIO.CGN
   163.163  157         	MOV	L,A	(HL) = address
   163.164  156         	MOV	L,M	(L) = link
A  163.165  046 000     	MVI	H,0
   163.167  042 164 114 	SHLD	AIO.CGN	Set CGN, Clear CSI
A  000.000              	ERRNZ	AIO.CSI-AIO.CGN-1
O  163.172  000 000 000 	RET
O  163.175  000 000 000 
                        **	LDD - Load Device Driver
                        *
                        *	LDD is called to perform the suspended load of a device driver.
                        *
                        *	IF some OVL code wishes to load a device driver, it must
                        *	suspend the request since the device driver will overlay the
                        *	OVL code.  After the OVL code exits, the resident code will call
                        *	LDD to perform the actual load, over the DVL.
                        *
                        *	ENTRY	DD.IOC = Pointer to IOC.DDA
                        *		DD.LDA = load address
                        *		DD.LEN = load length
                        *		DD.SEC = sector index on system device
                        *		DD.DTA = device resident address
                        *		DD.OPE = Open code (DC.OPR, DC.OPW, DC>OPU)
                        *	EXIT	OVL code destroyed
                        *	USES	None
O  163.200  000 000 000 
   045.357              S.DDSEC	EQU	S.DDGRP	Reference to make assemble ok
O  163.203  000 000 000 
   163.206  315 143 161 LDD	CALL	$SAVALL	Save registers
O  163.211  000 000 000 
                        *	Clear OVL resident flag
A  163.214  041 375 045 	LXI	H,S.OVLFL
   163.217  176         	MOV	A,M
A  163.220  346 376     	ANI	377Q-OVL.IN
   163.222  167         	MOV	M,A	Clear in flag
O  163.223  000 000 000 	
                        *	Load overlay
A  163.226  041 000 000 	LXI	H, S.OVLFL
   163.231  176         	MOV	A,M
A  163.232  346 376     	ANI	377Q-OVL.IN
                                                  	HEATH ASM #104.01.00.
                                                   	Page 25

   163.234  167         	MOV	M,A	Clear in flag
O  163.235  000 000 000 
                        *	Load overlay
   163.240  052 355 045 	LHLD	S.DDLEN	(HL) = length
   163.243  104         	MOV	B,H
   163.244  115         	MOV	C,L	(BC) is length
   163.245  052 353 045 	LHLD	S.DDLDA	(HL) is load address
   163.250  345         	PUSH	H	Save for later
O  163.251  000 000 000 	XCHG
   163.254  041 377 026 	LXI	H,SECSCR+255	Force new disk read right away
O  163.257  000 000 000 
                        *	Load binary
   163.262  315 013 164 LDD2	CALL	LDD8	Find next byte
   163.265  176         	MOV	A,M	(A) = Next byte
   163.266  022         	STAX	D	Copy
   163.267  023         	INX	D
   163.270  013         	DCX	B
   163.271  170         	MOV	A,B
   163.272  261         	ORA	C
O  163.273  000 000 000 	INZ	LDD2	More to go
O  163.276  000 000 000 	
                        *	Code all loaded, relocate it
   163.301  301         	POP	B	(BC) = REL factor
   163.302  005         	DCR	B
   163.303  005         	DCR	B
U  000.000              	ERRNZ	DD,ENT-2000A	Assume driver entry = 2000A
A  163.304  315 013 164 LDD3	CALL	LDD8
   163.307  136         	MOV	E,M
A  163.310  315 013 164 	CALL	LDD8
   163.313  126         	MOV	D,M	(DE) = rel adreese of workd to relocate
   163.314  172         	MOV	A,D
   163.315  263         	ORA	E
   163.316  312 343 163 	JZ	LDD4	All done
   163.321  353         	XCHG		(HL) = relative address of word to relocate
   163.322  011         	DAD	B	(HL) = absolute address of word to relocate
   163.323  176         	MOV	A,M
O  163.324  000 000 000 	Add	C
   163.327  167         	MOV	M,A
   163.330  043         	INX	H
   163.331  176         	MOV	A,M
   163.332  210         	ADC	B
   163.333  167         	MOV	M,A
   163.334  353         	XCHG		Restore (HL)
A  163.335  303 304 163 	JMP	LDD3
O  163.340  000 000 000 	
                        *	Setup entry addresses in tables
A  163.343  052 353 045 LDD4	LHLD	S.DDLDA
   163.346  353         	XCHG		(DE) = Entry address
   163.347  052 363 045 	LHLD	S.DDDTA	(HL) = address of devlst entry
   163.352  176         	MOV	A,M
   163.353  366 001     	ORI	DR.IM	Set in memory
   163.355  167         	MOV	M,A
   163.356  043         	INX	H
   163.357  043         	INX	H
AP 000.003              	ERRNZ	DEV.DDA-DEV.RES-2
   163.360  163         	MOV	M,E
   163.361  043         	INX	H
   163.362  162         	MOV	M,D	Set address in table
                                                  	HEATH ASM #104.01.00.
                                                   	Page 26

   163.363  353         	XCHG		(HL) = entry point address
   163.364  257         	XRA	A
   163.365  062 354 045 	STA	S.DDLDA+1	Clear Load Flag
   163.370  072 365 045 	LDA	S.DDOPC	(A) = Open Code
U  163.373  315 000 000 	CALL	PCHL	Call code
   163.376  303 126 161 	JMP	$RSTALL	Restore registers
O  164.001  000 000 000 	
   164.004  351         	PCHL	PCHL
O  164.005  000 000 000 	
                        **	LDD8 - read a byte from the file
                        *
                        *	ENTRY	(HL) = SecScr Pointer of current byte
                        *		S.DDSEC = sector number of next sector
                        *	EXIT	(HL) = address of next byte
                        *	USES	L
O  164.010  000 000 000 
   164.013  054         LDD8	INR	L	Point to next byte
   164.014  300         	RNZ		Got it
O  164.015  000 000 000 	
                        *	Must read another
O  164.020  000 000 000 
   164.023  305         	PUSH	B
   164.024  325         	PUSH	D
   164.025  345         	PUSH	H
   164.026  353         	XCHG		(DE) = address
A  164.027  001 000 001 	LXI	B,256
   164.032  052 357 045 	LHLD	S.DDSEC	(HL) = sector number to read
   164.035  043         	INX	H
   164.036  042 357 045 	SHLD	S.DDSEC	(HL) = next sector number to read
   164.041  053         	DCX	H	Restore (HL)
   164.042  315 127 162 	CALL	SREAD	Read it
   164.045  341         	POP	H
   164.046  321         	POP	D
   164.047  301         	POP	B
O  164.050  000 000 000 	RET
O  164.053  000 000 000 	
                        **	LDO - Load OVL code
                        *	LDO is called when the OVL Overlay must be loaded
                        *
                        *	IF User High Mem is too high, part of the user code will
                        *	have to be saved on the swap area before the OVL code can be
                        *	loaded.
                        *
                        *	ENTRY	None
                        *	EXIT	None
                        *	USES	A,F,H,L
O  164.056  000 000 000 
   164.061  325         LDO	PUSH	D
   164.062  305         	PUSH	B
                        *	See if will have to page user code
   164.063  052 002 046 	LHLD	S.OVLS	(HL) = size of HDOSOVL
   164.066  315 152 160 	CALL	$CHL	Complement (HL)
   164.071  353         	XCHG	(DE) = -size
   164.072  052 241 045 	LHLD	S.SYSM	(HL) = current FWA
   164.075  031         	DAD	D	(HL) = new FWA with OVL
   164.076  042 376 045 	SHLD	S.UCSF	Set user swap in case it is swapped
O  164.101  000 000 000 	XCHG
A  164.104  052 243 045 	LHLD	S.USRM
                                                  	HEATH ASM #104.01.00.
                                                   	Page 27

   164.107  175         	MOV	A,L
   164.110  223         	SUB	E
   164.111  157         	MOV	L,A
   164.112  223         	SUB	E
   164.113  157         	MOV	L,A
   164.114  174         	MOV	A,H
   164.115  232         	SBB	D
   164.116  147         	MOV	H,A	(HL) = amount to swap
U  164.117  332 000 000 	JC	LDG1	No need to swap
                        *	Must dump (HL) bytes of user code starting at (DE)
   164.122  305         	PUSH	B	check: is B really D?? 
   164.123  042 000 046 	SHLD	S.UCSL	SET LENGTH OF DUMP
   164.126  104         	MOV	B,H
   164.127  115         	MOV	C,L	(BC) = COUNT
   164.130  052 006 046 	LHLD	S.SSN	(HL) = SECTOR FOR SWAP (SET BY BOOT)
A  164.133  315 175 162 	CALL	SWRITE
A  164.136  041 375 045 	LXI	H,S.OVLFL
A  164.141  076 200     	MVI	A,OVL.UCS
   164.143  266         	ORA	M	SET USER CODE SWAPPED
   164.144  167         	MOV	M,A
   164.145  321         	POP	D	(DE) = ADDRESS TO LOAD
O  164.146  000 000 000 	
                        *	READY TO LOAD OVL OVERLAY
                        *	(DE) = ADDRESS
A  164.151  052 002 046 LDO1	LHLD	S.OVLS
   164.154  104         	MOV	B,H
   164.155  115         	MOV	C,L	(BC) = SIZE OF OVERLAY
A  164.156  052 010 046 	LHLD	S.OSN
   164.161  315 127 162 	CALL	SREAD	READ DATA
A  164.164  041 375 045 	LXI	H,S.OVLFL
   164.167  176         	MOV	A,M
   164.170  366 001     	ORI	OVL.IN	SET IT IN
   164.172  167         	MOV	M,A
                        *	Relocate OVL
   164.173  052 376 045 	LHLD	S.UCSF	(HL) = FWA OVERLAY LOAD
A  164.176  021 065 043 	LXI	D,PIC.COD
   164.201  104         	MOV	B,H
   164.202  115         	MOV	C,L	(BC) = OVL FWA
   164.203  031         	DAD	D	(HL) = ADDRESS OF ENTRY POINT
   164.204  042 004 046 	SHLD	S.OVLE	SET ENTRY POINT
A  000.000              	ERRNZ	PIC.PTR-PIC.COD+2
   164.207  053         	DCX	H
   164.210  176         	MOV	A,M
   164.211  053         	DCX	H
   164.212  176         	MOV	A,M
   164.213  053         	DCX	H
   164.214  156         	MOV	L,M
   164.215  147         	MOV	H,A	(HL) = RELATIVE ADDRESS OF TABLE
   164.216  011         	DAD	B	(HL) = ABSOLUTE ADDRESS OF TABLE
   164.217  315 300 164 	CALL	REL.	RELOCATE OVL
O  164.222  000 000 000 	
   164.225  301         	POP	B
   164.226  321         	POP	D
O  164.227  000 000 000 	RET
O  164.232  000 000 000 
                        ** line 1862
                        **	PDI - prepare for device I/)
                        *	PDI preparees for physical I/O by
                                                  	HEATH ASM #104.01.00.
                                                   	Page 28

                        *	  1) computing the physical addresses
                        *	  2) prepare the count
                        *
                        *	ENTRY	AIO.XXX setup
                        *	EXIT	(BC) = count
                        *		(HL) = sector
                        *		(A) = 0
                        *	USES	A,F,B,C,H,L
O  164.235  000 000 000 
   164.240  052 124 157 PDI	LHLD	AIO.TFP	(L) = AIO.CGN, (H) = AIO.CSI
   000.000              	ERRNZ	AIO.CSI-AIO.CGN-1	
   164.243  072 163 114 	LDA	AIO.SPG	(A) = sectors per group
   164.246  117         	MOV	C,A
   164.247  175         	MOV	A,L	(A) = group number
   164.250  154         	MOV	L,H
   164.251  046 000     	MVI	H,0	(HL) = (0, CSI)
   164.253  104         	MOV	B,H	(BC) = (0, SPG)
                        *	Compute sector number by adding SPG 'BLock Number' Times
   164.254  011         PDI1	DAD	B	add
   164.255  075         	DCR	A
   164.256  302 254 164 	JNZ	PDI1	more to go
   164.261  072 121 157 	LDA	AIO.CNT	(A) = count
   164.264  110         	MOV	C,B	(C) = 0
   164.265  107         	MOV	B,A	(B) = sector count
   164.266  257         	XRA	A	clear (A)
O  164.267  000 000 000 	RET
O  164.272  000 000 000 	
                        **	REL - relocate code
                        *	REL processes a relocation list
                        *
                        *	ENTRY	(BC) = displacement from addresses
                        *		(DE) = reloaction factor (from current address)
                        *		(HL) = FWA relocation list
                        *	EXIT	None
                        *	USES	All
O  164.275  000 000 000 
   164.300  120         REL.	MOV	D,B	Entry for code displace = rel factor
   164.301  131         	MOV	E,C
O  164.302  000 000 000 	
   164.305  325         REL	PUSH	D	Save relocation factor
   164.306  136         	MOV	E,M	
   164.307  043         	INX	H
   164.310  126         	MOV	D,M
   164.311  043         	INX	H	(DE) = relative address of word to relocate
   164.312  172         	MOV	A,D
   164.313  263         	ORA	E
U  164.314  302 000 000 	JNZ	REL1	More to do
   164.317  321         	POP	D
   164.320  311         	RET		Exit
O  164.321  000 000 000 	
                        *	(DE) = index of word to relocate
                        *	(HL) = relocation table address
                        *	(BC) = code displacement factor
                        *	((SP)) = code relocation factor
O  164.324  000 000 000 
O  164.327  000 000 000 REL1	XCHG
   164.332  011         	DAD	B	(HL) = absolute address of word to relocate
   164.333  353         	XCHG		(DE) = abs code address, (HL) = rel table addr
                                                  	HEATH ASM #104.01.00.
                                                   	Page 29

   164.334  343         	XTHL		(HL) = code rel factor
   164.335  032         	LDAX	D
   164.336  205         	ADD	L	Relocate word of code
   164.337  022         	STAX	D
   164.340  023         	INX	D
   164.341  032         	LDAX	D
   164.342  214         	ADC	H
   164.343  022         	STAX	D	Relocate
   164.344  353         	XCHG		(DE) = relocation factor
   164.345  341         	POP	H	(HL) = relocation table entry address
   164.346  303 305 164 	JMP	REL	Do It again
O  164.351  000 000 000 	
O  164.354  000 000 000 
                        **	TFE - Test for EOF
                        *
                        *	TFE checks for end of file - indicated by
                        *	  1) AIO.CGN = AIO.LGN
                        *	  2) AIO.CSI = AIO.LSI
                        *
                        *	ENTRY	None
                        *	EXIT	'Z' clear if NOT EOF
                        *		(A) = 0
                        *		'Z' set if EOF
                        *		'C' set
                        *		(A) = EC.EOF
                        *	USES	A,F,H,L
O  164.357  000 000 000 
A  164.362  052 166 114 TFE	LHLD	AIO.LGN
A  000.000              	ERRNZ	AIO.LSI-AIO.LGN-1
A  164.365  072 164 114 	LDA	AIO.CGN
   164.370  275         	CMP	L
A  164.371  076 000     	MVI	A,0
   164.373  300         	RNE		Not EOF
A  164.374  072 165 114 	LDA	AIO.CSI
   164.377  274         	CMP	H
A  165.000  076 000     	MVI	A,0
   165.002  300         	RNE		Not EOF
V  165.003  076 001     	MVI	A,EC.EOF*2+1	set EOF code
   165.005  311         	RET		
O  165.006  000 000 000 
                        **	RUC - restore user code
                        *	RCU restores the user program code which was swapped
                        *	for the OVL code.  Since RUC resides in the OVL area,
                        *	it may not retrun after the disk I/O call
                        *
                        *	ENTRY	None
                        *	EXIT	None
                        *	Uses	None
O  165.011  000 000 000 
U  165.014  315 000 000 RUC	CALL	#SAVALL	Save registers
UA 165.017  041 000 000 	LXI	H,#RSTALL
   165.022  345         	PUSH	H	Resturn via $RSTALL
A  165.023  041 375 045 	LXI	H,S.OVLFL
   165.026  176         	MOV	A,M
   165.027  247         	ANA	A
A  000.000              	ERRNZ	OVL.UCS-200Q
   165.030  360         	RP			Not swapped
   165.031  346 176     	ANI	377Q-OVL.UCS-OVL.IN	Restore user code, remove OVL
                                                  	HEATH ASM #104.01.00.
                                                   	Page 30

   165.033  167         	MOV	M,A
                        *	Restore user code
A  165.034  052 000 046 	LHLD	S.UCSL
   165.037  104         	MOV	B,H
   165.040  115         	MOV	C,L	(BC) = COUNT
A  165.041  052 376 045 	LHLD	S.UCSF
   165.044  353         	XCHG		(DE) = ADDRESS
   165.045  052 006 046 	LHLD	S.SSN	(HL) = sector for swap
   165.050  303 127 162 	JMP	SREAD	Read and exit.
O  165.053  000 000 000 	
                        **	SYDD - system disk device driver
                        *	SYDD is the HDOS system H17 device driver
                        *
                        *	ENTRY	(A) = DC.XXX function code
                        *		Other registers set as needed by function
                        *		Registers set by function
                        *		'C' set, error
                        *		(A) = error code
                        *	USES	All
O  165.056  000 000 000 
A                       R.SYDD	EQU	*
AP 043.043              	ERRNZ	DC.REA
   165.061  247         	ANA	A
A  165.062  312 256 042 	JZ	D.READ
AP 043.043              	ERRNZ	DC.WRI-1
   165.065  075         	DCR	A
A  165.066  312 264 042 	JZ	D.WRITE
AP 043.043              	ERRNZ	DC.RER-2
   165.071  075         	DCR	A
   165.072  312 261 042 	JZ	D.READR	READ regardless
AV 165.075  376 050     	CPI	DC.ABT-2
   165.077  332 245 042 	JC	D.XOK	Is not abort or mount, ignore
UAP334.325              	ERRNZ	DC.MOU-DC.ABT-1
   165.102  312 250 042 	JE	D.ABORT	is abort
A  165.105  303 242 042 	JMP	D.MOUNT
O  165.110  000 000 000 
                        ***	Mount - mount new device
                        *
                        *	Mount processes device dependent mounting of new media
                        *
                        *	The volume serial (number?) is read into the volume table
                        *	and the heads are homed.
                        *
                        *	ENTRY 	(L) = volume number (if any)
                        *	EXIT	(not specified in source)
                        *	USES	(Not specified in source)
O  165.113  000 000 000 
A                       R.MOUNT	EQU	*
   165.116  105         	MOV	B,L	(B) = volume serial
   165.117  041 000 000 	LXI	H,0	Set sector index
   165.122  315 314 042 	CALL	D.SDP	Set device parameters
   165.125  315 322 042 	CALL	D.STZ	Seek track 0
A  165.130  052 367 042 	LHLD	D.VOLPT
   165.133  160         	MOV	M,B	Set volume number
   165.134  303 245 042 	JMP	D.XOK	Exit with stuff ok
O  165.137  000 000 000 	
                        ***	ABORT - abort any active I/O
                        *	Abort causes any on-going I/O to be aborted
                                                  	HEATH ASM #104.01.00.
                                                   	Page 31

O  165.142  000 000 000 
A                       R.ABORT	EQU	*
   165.145  315 314 042 	CALL	D.SDP	Set device parameters
   165.150  315 322 042 	CALL	D.STZ	Seek track zero
F  165.161              	SET	R.XOK	Implicit reference to R.XOK
                        *	JMP	D.XOK	Exit as if ok (note: source has line commented out)
O  165.153  000 000 000 
                        ***	XOK - exit with all ok flag
O  165.156  000 000 000 
   165.161  257         R.XOK	XRA	A
   165.162  365         R.XIT	PUSH	PSW	Save status
A  165.163  072 361 042 XIT1	LDA	D.DLYHS
   165.166  247         	ANA	A
   165.167  302 163 165 	JNZ	XIT1	Wait for hardware delays
   165.172  363         	DI		Lock out clock
A  165.173  072 357 042 	LDA	D.DVCTL
   165.176  346 220     	ANI	DF.MO+DF.WR	Remove device select
   165.200  323 177     	OUT	DP.DC	Deselect motor
   165.202  062 357 042 	STA	D.DVCTL	update byte
A  165.205  052 206 042 	LHLD	D.XITA
   165.210  042 360 042 	SHLD	D.DLYMO	Set 120/2 seconds of motor on
   000.000              	ERRNZ	D.DLYHS-D.DLYMO-1	Set 7*2 mS of head unsettle
   165.213  361         	POP	PSW
   165.214  373         EIXIT	EI		Restore interrups
O  165.215  000 000 000 	RET
O  165.220  000 000 000 
                        ***	Clock - Process clock interrupts
                        *
UA 165.223  072 000 000 CLOCK	LDA	.TICCNT
O  165.226  000 000 000 	RRC
   165.231  330         	RC		Not even
   165.232  247         	ANA	A
A  165.233  041 360 042 	LXI	H,D.DLYMO
   165.236  302 264 165 	JNZ	CLOCK1	Not half second
   165.241  075         	DCR	A	(A) = -1
   165.242  206         	ADD	M	Subtract one
   165.243  322 264 165 	JNC	CLOCK1	Was zero
   165.246  167         	MOV	M,A	Update
   165.247  302 264 165 	JNZ	CLOCK1	Not time for motor off
   165.252  072 357 042 	LDA	D.DVCTL	
   165.255  346 200     	ANI	DF.WR	Remove all but RAM/WRITE
A  165.257  062 357 042 	STA	D.DVCTL
   165.262  323 177     	OUT	DP.DC	Off motor
   165.264  043         CLOCK1	INX	H	(HL) = $DLYHS
A  000.000              	ERRNZ	D.DLYHS-D.DLYMO-1
   165.265  176         	MOV	A,M	(A) = D.DLYHS
A  165.266  326 001     	SUI	1
   165.270  330         	RC		Was zero
   165.271  167         	MOV	M,A
   165.272  311         	RET	
O  165.273  000 000 000 	
                        ***	READ - read from disk
                        *
                        *	ENTRY	(BC) = count
                        *		(DE) = address
                        *		(HL) = block number
                        *		Interrupts enabled
                        *	EXIT	(DE) =next unused address
                                                  	HEATH ASM #104.01.00.
                                                   	Page 32

                        *		Interrupts disabled
                        *	USES	All
O  165.276  000 000 000 
   165.301  345         R.READ	PUSH	H	SAVE (HL)
   165.302  315 314 042 	CALL	D.SDP	SETUP DEVICE PARAMETERS
A  165.305  052 021 043 	LHLD	D.OPR
   165.310  043         	INX	H
   165.311  042 021 043 	SHLD	D.OPR	COUNT OPERATION
O  165.314  000 000 000 	
                        *	read to read sector
                        *	(BC) = amount
                        *	(DE) = address
                        *	((SP)) = sector number
O  165.317  000 000 000 
   165.322  341         READ1	POP	H	(HL) = sector number
   165.323  325         	PUSH	D	Save address
   165.324  171         	MOV	A,C	Adjust (B) so that (B) = # of whole or partial
   165.325  247         	ANA	A	sectors to read. (C) = bytes of last sector to
   165.326  312 340 165 	JZ	READ1.5	read. (C) = 0 if to read entire last sector
   165.331  004         	INR	B
O  165.332  000 000 000 
                        **	**** NOTE ****
                        *	This code runs with interrrupts disabled from here on
O  165.335  000 000 000 
   165.340  305         READ1.5	PUSH	B	Save count
   165.341  315 272 042 	CALL	D.DTS	Decode track and sector
   165.344  076 001     READ2	MVI	A,1	(A) = delay count for start
                        *	Look for right sector
                        *	(A) = delay count before search
O  165.346  000 000 000 
   165.351  315 325 042 READ2.4	CALL	D.UDLY	Delay some uS
   165.354  315 306 042 	CALL 	D.LPS	Locate proper sector
   165.357  332 151 166 	JC	READ7	ERROR
   165.362  301         	POP	B	(BC) = count
   165.363  341         	POP	H	(HL) = address for data
O  165.364  000 000 000 	
                        *	check amount to read
O  165.367  000 000 000 
   165.372  170         READ3	MOV	A,B
   165.373  261         	ORA	C
   165.374  312 171 166 	JZ	READ8	No more to read
   165.377  345         	PUSH	H
   166.000  305         	PUSH	B	Save count and address in case of error
   166.001  005         	DCR	B	See if on last (maybe partial) sector
   166.002  312 007 166 	JZ	READ3.5	On last sector, read (C) count
                        ***** Start of page 43
   166.005  016 000     	MVI	C,0	will read all 256 bytes
   166.007  101         READ3.5	MOV	B,C	(B) = # to read +1, (C) = # to skip
   166.010  315 330 042 	CALL	D.WSC	Wait for sync character
   166.013  332 127 166 	JC	READ71	Didn't get one
O  166.016  000 000 000 
                        *	READ DATA
   166.021  315 311 042 READ4	CALL	D.RDB	READ BYTE
   166.024  167         	MOV	M,A	STORE
   166.025  043         	INX	H
   166.026  005         	DCR	B
   166.027  302 021 166 	JNZ	READ4	MORE TO GO
   166.032  171         	MOV	A,C
                                                  	HEATH ASM #104.01.00.
                                                   	Page 33

   166.033  247         	ANA	A
   166.034  312 051 166 	JZ	READ6	NONE TO DISCARD
O  166.037  000 000 000 	
                        *	READ, CHECKSUM, AND DISCARD DATA
A  166.042  315 311 042 READ5	CALL	D.RDB
   166.045  014         	INR	C
A  166.046  302 042 166 	JNZ	READ5
   166.051  102         READ6	MOV	B,D	(B) = CHECKSUM
A  166.052  315 311 042 	CALL	D.RDB
   166.055  270         	CMP	B
   166.056  302 140 166 	JNE	READ72	CHECKSUM ERROR
O  166.061  000 000 000 
                        *	GOT GOOD SECTOR
   166.064  301         	POP	B	(BC) = OLD COUNT
   166.065  005         	DCR	B	COUNT SECTOR READ
   166.066  312 171 166 	JZ	READ8	JUST READ LAST ONE
O  166.071  000 000 000 	
                        *	HAVE MORE TO READ
   166.074  343         	XTHL		SAVE ADDRESS
   166.075  305         	PUSH	B	SAVE COUNT
A  166.076  041 356 042 	LXI	H,D.TS
   166.101  064         	INR	M	COUNT SECTOR
A  166.102  076 012     	MVI	A,10
   166.104  226         	SUB	M
A  166.105  076 000     	MVI	A,0
   000.000              	ERRNZ	30*64*2/15-1000A	(A) = time to delay for 30 char's
   166.107  302 344 165 	JNE	READ2,4	Not at end of track
   166.112  167         	MOV	M,A	Sector # = 0
A  000.000              	ERRNZ	D.TS-D.TT-1
   166.113  053         	DCX	H
   166.114  064         	INR	M
   166.115  373         	EI		Restore interrupts until *STS* called
   166.116  315 275 042 	CALL	D.SDT	Seek desired track
A  166.121  303 344 165 	JMP 	READ2
O  166.124  000 000 000 	
                        *	Can't get data, header or checksum problem
   166.127  041 010 043 READ71	LXI	H,D.E.MDS	Missing data sync error
A  166.132  315 341 042 	CALL	D.ERRT
A  166.135  303 151 166 	JMP	READ7
   166.140  041 012 043 READ72	LXI	H,D.E.CHK	CHecksum error
A  166.143  315 341 042 	CALL	D.ERRT
O  166.146  000 000 000 	
   166.151  315 267 042 READ7	CALL	D.CDE	Count disk error
   166.154  322 344 165 	JNC	READ2	Try again
   166.157  301         	POP	B
   166.160  321         	POP	D
V  166.161  076 021     	MVI	A,EC.RF	Read failure
   166.163  303 253 042 	JMP	D.XIT	Too many errors, too bad
O  166.166  000 000 000 	
                        * 	Entire read was ok
   166.171  341         READ8	POP	H	Clean stack
   166.172  303 245 042 	JMP	D.XOK	Exit ok
O  166.175  000 000 000 	
                        ***	READR - read disk regardless of volume protection
                        *
                        *	ENTRY	(BC) = count
                        *		(DE) = address
                        *		(HL) = block #
                                                  	HEATH ASM #104.01.00.
                                                   	Page 34

                        *	EXIT	(DE) = next unused address
                        *	USES	All
O  166.200  000 000 000 
   166.203  345         R.READR	PUSH	H	Save (HL)
   166.204  315 314 042 	CALL	D.SDP	Setup device parameters
A  166.207  041 157 162 	LXI	H,ZEROS
A  166.212  042 367 042 	SHLD	D.VOLPT
   166.215  303 322 165 	JMP	READ1	Process as regular read
O  166.220  000 000 000 	
                        ***	WRITE - process disk write
                        *
                        *	ENTRY	(BC) = count
                        *		(DE) = address
                        *		(HL) = block #
                        *	EXIT	(LINK) = last block #
                        *	USES	All
O  166.223  000 000 000 
A                       R.WRITE	EQU	*
   166.226  345         	PUSH	H	Save block #
   166.227  315 314 042 	CALL	D.SDP	Set device parameters
A  166.232  052 023 043 	LHLD	D.OPW
   166.235  043         	INX	H
   166.236  042 023 043 	SHLD	D.OPW	Count operation
   166.241  333 177     	IN	DP.DC	See if dick write protected
A  166.243  346 004     	ANI	DF.WP
O  166.245  000 000 000 	STC
AV 166.250  076 024     	MVI	A,EC.WP
   166.252  302 062 167 	JNZ	WRITE8	Disk is write protected
O  166.255  000 000 000 	
                        *** Ready to write sector
                        *
                        *  (BC) = count
                        *  (DE) = address
                        *   ((SP)) = sector number
O  166.260  000 000 000 
A  166.263  041 377 000 	LXI	H,377Q
   166.266  011         	DAD	B
   166.267  104         	MOV	B,H	(B) = # sectors to write
O  166.270  000 000 000 	
   166.273  341         WRITE1	POP	H	(HL) = sector number
   166.274  325         	PUSH	D	Save address
O  166.275  000 000 000 	
                        *	** NOTE **
                        * This code runs with interrupts disabled form this point on
   166.300  315 272 042 	CALL	D.DTS	Determine track and sector
   166.303  076 001     WRITE2	MVI	A,1	(A) = short delay count
O  166.305  000 000 000 
                        * find right sector (A0 = delay count
   166.310  315 325 042 WRIT2.5	CALL	D.UDLY	Delay some microsecs
   166.313  305         	PUSH	B	Save count
   166.314  315 306 042 	CALL	D.LPS	Locate proper sector
   166.317  301         	POP	B	(BC) = count
   166.320  332 052 167 	JC	WRITE7	Can't find it
   166.323  341         	POP	H	(HL) = address
   166.324  072 210 042 	LDA	D.WRITA	(A) = guardband delay
   166.327  075         WRITE4	DCR	A
   166.330  302 327 166 	JNZ	WRITE4	Pause over guardband
A  166.333  072 211 042 	LDA	D.WRITB
                                                  	HEATH ASM #104.01.00.
                                                   	Page 35

   166.336  117         	MOV	C,A	(C) = # of 00 characters
   166.337  072 212 042 	LDA	D.WRITC	(A) = 128/2 = two character times before writing
   166.342  315 333 042 	CALL	D.WSP	Write sync pattern
O  166.345  000 000 000 
   166.350  176         WRITE5	MOV	A,M
A  166.351  315 336 042 	CALL	D.WNB
   166.354  043         	INX	H
   166.355  015         	DCR	C
   166.356  302 350 166 	JNZ	WRITE5	Not done yet so loop
   166.361  172         	MOV	A,D	(A) = checksum
   166.362  315 336 042 	CALL	D.WNB	Write checksum
O  166.365  000 000 000 	
                        *	Have completed writing, leave write-gate open for 3 character times
                        *	to finish tunnel erasing
O  166.370  000 000 000 
A  166.373  315 336 042 	CALL 	D.WNB
A  166.376  315 336 042 	CALL	D.WNB
A  167.001  315 336 042 	CALL	D.WNB
A  167.004  072 357 042 	LDA	D.DVCTL
   167.007  323 177     	OUT	DP.DC	Off disk control
   167.011  005         	DCR	B
   167.012  312 245 042 	JZ	D.XOK	All done
   167.015  345         	PUSH	H	SAVE ADDRESS
A  167.016  041 356 042 	LXI	H,D.TS
   167.021  064         	INR	M
A  167.022  076 012     	MVI	A,10
   167.024  226         	SUB	M
A  167.025  076 000     	MVI	A,0
   000.000              	ERRNZ	30*64*2/15-1000A	(A) = ct to delay 30 character x
   167.027  302 310 166 	JNZ	WRIT2.5	Not at end of track
O  167.032  000 000 000 	
                        *	move to next track
A  000.000              	ERRNZ	D.TS-D.TT-1
   167.035  167         	MOV	M,A	clear current sector index
   167.036  053         	DCX	H
   167.037  064         	INR	M
   167.040  373         	EI		Restore interrupts until *STS* call
   167.041  315 275 042 	CALL	D.SDT	Seek desired track
A  167.044  303 303 166 	JMP	WRITE2
O  167.047  000 000 000 	
                        *	ERROR
   167.052  315 267 042 WRITE7	CALL	D.CDE	Count disk error
   167.055  322 303 166 	JNC	WRITE2	try again
V  167.060  076 022     	MVI	A,EC.WF	write failure
   167.062  341         WRITE8	POP	H	restore stack
   167.063  303 253 042 	JMP	D.XIT	Too many .. try again
O  167.066  000 000 000 	
                        ***	CDE - count disk errors
                        *	CDE is called when a disk soft error occurs.  If there have 
                        *	been 10 soft errors for this operation then a hard error
                        *	is flagged.
                        *
                        *	ENTRY	None
                        *	EXIT	'C' set if hard error
                        *		Interrupts disabled
                        *	USES	A,F,H,L
O  167.071  000 000 000 
O  167.074  000 000 000 R.CDE	EI
                                                  	HEATH ASM #104.01.00.
                                                   	Page 36

   167.077  315 322 042 	CALL	D.STZ	Seek track zero
   167.102  315 275 042 	CALL	D.SDT	seek desired track
   167.105  247         	ANA	A	Clear carry
A  167.106  052 002 043 	LHLD	D.SECNT
   167.111  043         	INX	H
   167.112  042 002 043 	SHLD	D.SECNT	Increment count
   167.115  041 004 043 	LXI	H,D.OECNT	(HL) = # operation error count
   167.120  065         	DCR	M
   167.121  360         	RP		Not too many
   167.122  053         	DCX	H	
A  167.123  076 366     	MVI	A,-ERPTCNT
   167.125  206         	ADD	M	Remove soft count
   167.126  167         	MOV	M,A
A  000.000              	ERRNZ	D.SECNT-D.HECNT-1
   167.127  064         	INR	M	Count hard error
O  167.130  000 000 000 	STC
   167.133  311         	RET		Exit with 'C' set
O  167.134  000 000 000 	
                        ***	DTS - decode track and sector
                        *	DTS decodes the track and sector number from
                        *	the supplied sector index
                        *
                        *	ENTRY	(HL) = sector index
                        *		Interrupts enabled
                        *	EXIT	D.TS = sector number
                        *		D.TT = track number
                        *		Interrupts disabled
                        *	USES	A,F,H,L
O  167.137  000 000 000 
   167.142  305         R.DTS	PUSH	B	Save (BC)
   167.143  001 366 377 	LXI	B,-10	
   167.146  170         	MOV	A,B	(A) = 377Q
   167.147  074         DTS1	INR	A
   167.150  011         	DAD	B
A  167.151  332 147 167 	JC	DTS1
   167.154  062 355 042 	STA	D.TT	Set track number
   167.157  175         	MOV	A,L
A  167.160  306 012     	ADI	10
   167.162  062 356 042 	STA	D.TS	Set sector	
   167.165  301         	POP	B	restore (BC)
   167.166  303 206 167 	JMP	R.SDT	Seek desired track
O  167.171  000 000 000 
                        *** 	SDT - set desired track
                        *	SDT moves the disk arm to the desired (D.TT) track
                        *
                        *	ENTRY	None
                        *	EXIT	None
                        *	USES	A,F,H,L
O  167.174  000 000 000 
                        *	Move arm in
   167.177  064         SDT3	INR	M
A  167.200  315 300 042 	CALL	D.MAI
O  167.203  000 000 000 	
A  167.206  052 365 042 R.SDT	LHLD	D.TRKPT
O  167.211  000 000 000 	LAD	D.TT
   167.214  276         	CMP	M
   167.215  312 317 042 	JE	D.STS	Got there
   167.220  362 177 167 	JP	SDT3	Must move in
                                                  	HEATH ASM #104.01.00.
                                                   	Page 37

O  167.223  000 000 000 	
                        *	Move arm out
   167.226  065         SDT1	DCR	M	update track number
   167.227  315 303 042 	CALL	D.MAO	move arm out
   167.232  303 206 167 	JMP	R.SDT	see if arm there yet
O  167.235  000 000 000 	
                        ***	MAI - move disk arm in one track
                        *
                        *	ENTRY	None
                        *	EXIT	None
                        *	USES	A,F
O  167.240  000 000 000 
                        ***	MAO - move disk arm out
                        *
                        *	ENTRY	None
                        *	EXIT	None
                        *	USES	A,F
O  167.243  000 000 000 
   167.246  076 040     R.MAI	MVI	A,DF.DI	Set direction	
   167.250  376         	DB	MI.CPI	Gobble XRA instruction
O  167.251  000 000 000 
   167.254  257         R.MAO	XRA	A	Set direction
   167.255  345         	PUSH	H
   167.256  147         	MOV	H,A
A  167.257  072 357 042 	LDA	D.DVCTL
A  167.262  346 237     	ANI	377Q-DF.DI-DF.ST
   167.264  264         	ORA	H	Set direction
   167.265  323 177     	OUT	DP.DC	set direction
   167.267  341         	POP	H
A  167.270  366 100     	ORI	DF.ST
   167.272  323 177     	OUT	DP.DC	Start step
A  167.274  356 100     	XRI	DF.ST
   167.276  323 177     	OUT	DP.DC	Complete step
   167.300  072 213 042 	LDA	D.MAIA	(A) = MS/2 for track timing
   042.344              .	SET	D.DLY	Set reference to ROM {note period in 1st char}
                        *	JMP	D.DLY	Delay 8 mS
O  167.303  000 000 000 
                        ***	DLY - delay by front panel clock
                        *
                        ***	MAI - move disk arm in one track
                        *
                        *	ENTRY	(A) = millisecond count/2
                        *	EXIT	None
                        *	USES	A,F
   167.306  345         R.DLY	PUSH	H
UA 167.307  041 000 000 	LXI	H,.TICCNT
   167.312  206         	ADD	M
   167.313  276         DLY1	CMP	M
A  167.314  302 313 167 	JNE	DLY1
   167.317  341         	POP	H
O  167.320  000 000 000 	RET
O  167.323  000 000 000 	
                        ***	LPS - Locate proper sector
                        *	LPS reads over sector headers until the proper sector
                        *	is found.
                        *
                        *	Upon entry, the arm should be positioned over the sector.
                        *
                                                  	HEATH ASM #104.01.00.
                                                   	Page 38

                        *	D.TT = desired track
                        *	D.TS = desired sector
                        ***	MAI - move disk arm in one track
                        *
                        *	ENTRY	None
                        *	EXIT	Interrrups disabled
                        *		'C' set if error
                        *	USES	All but C
O  167.326  000 000 000 
   167.331  315 317 042 LPS0	CALL	D.STS	Skip this sector
O  167.334  000 000 000 
   167.337  072 214 042 R.LPS	LDA	D.LPSA	(A) = #trys for this sector
   167.342  107         	MOV	B,A
A  167.343  072 361 042 	LDA	D.DLYHS
   167.346  247         	ANA	A
A  167.347  302 331 167 	JNZ	LPS0
O  167.352  000 000 000 	
O  167.355  000 000 000 LPS1	DI
   167.360  315 330 042 	CALL	D.WSC	wait for sync character
   167.363  332 064 170 	JC	LPS3	none
A  167.366  052 367 042 	LHLD	D.VOLPT
A  167.371  315 311 042 	CALL	D.RDB
   167.374  276         	CMP	M	see if proper volume
   167.375  302 074 170 	JNE	LPS4	wrong volume
A  170.000  041 355 042 	LXI	H,D.TT
A  170.003  315 311 042 	CALL	D.RDB
   170.006  276         	CMP	M	see if proper track
   170.007  302 104 170 	JNE	LPS5	wrong track
A  000.000              	ERRNZ	D.TS-D.TT-1
   170.012  043         	INX	H
A  170.013  315 311 042 	CALL	D.RDB
   170.016  276         	CMP	M
   170.017  302 050 170 	JNE	LPS2	wrong sector
O  170.022  000 000 000 	
                        *	got right sector, read checksum
   170.025  142         	MOV	H,D
A  170.026  315 311 042 	CALL	D.RDB
   170.031  274         	CMP	H
   170.032  310         	RE		ALL OK
   170.033  056 013     	MVI	L,#D.E.HCK	Header checksum error
   170.035  046 043     LPS1.5	MVI	H,D.ERR/256	(HL) = error byte address
AF 000.043              	SET	D.ERR/256
AP 000.043              	ERRNZ	D.ERRL/256-	Must in same bank
   170.037  315 341 042 	CALL	D.ERRT	Count error
O  170.042  000 000 000 	
                        *	Wrong sector or bad data. Try some more
O  170.045  000 000 000 
   170.050  315 317 042 LPS2	CALL	D.STS	Skip this sector
   170.053  005         	DCR	B
U  170.054  322 000 000 	JNC	LPS1	Try again
   170.057  067         	STC		Enough trys
   170.060  311         	RET		ERROR
O  170.061  000 000 000 	
   170.064  056 011     LPS3	MVI	L,#D.E.HSY	Header sync error
A  170.066  303 035 170 	JMP	LPS1.5
O  170.071  000 000 000 	
   170.074  056 014     LPS4	MVI	L,#D.E.VOL	Bad volume number
   170.076  303 035 170 	JMP	LPS1.5	count error
                                                  	HEATH ASM #104.01.00.
                                                   	Page 39

O  170.101  000 000 000 	
   170.104  056 015     LPS5	MVI	L,#D.E.TRK	Bad track number
A  170.106  303 035 170 	JMP	LPS1.5
O  170.111  000 000 000 
                        ***	RDB - Read byte from disk
                        *	RDB reads the next byte from the disk
                        *
                        *	ENTRY	(D) = checksum
                        *	EXIT	(A) = byte
                        *		(D) updated
                        *	USES	A,F,D,E
O  170.114  000 000 000 
A  170.117  333 175     R.RDB	IN	UP.ST
A  000.000              	ERRNZ	UF.RDA-1
O  170.121  000 000 000 	RAR
   170.124  322 117 170 	JNC	R.RDB	Not ready yet
   170.127  333 174     	IN	UP.DP	(A) = data
   170.131  137         	MOV	E,A
   170.132  252         	XRA	D	Differ
   170.133  007         	RLC		Shift left
   170.134  127         	MOV	D,A	Replace
   170.135  173         	MOV	A,E	(A) = char
O  170.136  000 000 000 	RET
O  170.141  000 000 000 	
                        ***	SDP - set device parameters
                        *	SDP sets up arguements for the specific unit
                        *	D.DVCTL = motor on, device select
                        *	D.TRKPT = address of device track number
                        *
                        *	ENTRY	AIO.UNI = unit number
                        *	EXIT	(HL)= (D.TRKPT)
                        *	USES	A,F,H,L
O  170.144  000 000 000 
A  170.147  076 012     R.SDP	MVI	A,ERPTCNT
U  170.151  062 000 000 	STA	D,OECNT	Set max error count for operation	
A  170.154  072 176 114 	LDA	AIO.UNI
   170.157  365         	PUSH	PSW	save unit number
   170.160  074         	INR	A	(A) =1 if Dev 0, 2 if dev 1
   170.161  207         	ADD	A
   000.000              	ERRNZ	DF.DSO-2	Select 0 or 1
   000.000              	ERRNZ	DF.DS1-4	
   170.162  363         	DI		Interlock clock interrupts
A  170.163  041 357 042 	LXI	H,D.DVCTL
   170.166  256         	XRA	M
A  170.167  346 177     	ANI	377Q-DF.WR
   170.171  256         	XRA	M	Merge with DF.WR bit from D.DVCTL
   170.172  366 020     	ORI	DF.MO	Motor on
   170.174  167         	MOV	M,A	update
U  170.175  323 000     	OUT	DP.UC	Select drive, load head
O  170.177  000 000 000 	
                        *	See if heads have been unloaded logn enough to require load delay
A  170.202  041 361 042 	LXI	H,D.DLYHS
   170.205  176         	MOV	A,M
   170.206  247         	ANA	A
A  170.207  066 000     	MVI	M,0
A  170.211  302 220 170 	JNZ	SDP1
A  170.214  072 215 042 	LDA	D.SDPA
   170.217  167         	MOV	M,A
                                                  	HEATH ASM #104.01.00.
                                                   	Page 40

   170.220  053         SDP1	DCX	H
AP 042.360              	ERRNZ	D.DLYMO=D.DLYAS+1	(HL) = #D.DLYMO
   170.221  176         	MOV	A,M	(A) = motor on delay
   170.222  066 170     	MVI	M,120	60 secs before turn off again
   170.224  247         	ANA	A	'Z' if motor turned off
   170.225  043         	INX	H	(HL) = #D.DLYHS
U  170.226  302 000 000 	JNZ	SDP2	Motor is still on
   170.231  072 216 042 	LDA	D.SDPB	(A) = motor wait time (mS/4)
   170.234  167         	MOV	M,A
O  170.235  000 000 000 SDP2	EI
   170.240  361         	POP	PSW	(A) = unit number
   170.241  207         	ADD	A	(A) = 2*unit number
A  170.242  041 371 042 	LXI	H,D.DRVTB
   170.245  205         	ADD	L
   170.246  157         	MOV	L,A	(HL) = address of track entry
A  170.247  042 365 042 	SHLD	D.TRKPT
   170.252  043         	INX	H
   170.253  042 367 042 	SHLD	D.VOLPT	set volume number
O  170.256  000 000 000 	RET
O  170.261  000 000 000 	
                        ***	STS - skip this sector
                        *	STS is called to skip the current sector, regardless of where
                        *	the head is positioned.
                        *	
                        *	STS will exit at the beginning of the next sector
                        *
                        *  1. if the head is not over a hole, wait 8 mS while
                        *     hole checking. If no hole in this time, when we are in
                        *     a regular gap.  Wait for the next hole and exit.
                        *
                        *  2. If the head is over a hole or becomes so during the 8 mS wait,
                        *     then wait for the hole to pass.  Wait 12 mS in case of the index
                        *     then wait for the next hole and exit.
                        *
                        *	ENTRY	None
                        *	EXIT	Interrrups disabled
                        *	USES	A,F,H,L
O  170.264  000 000 000 
O  170.267  000 000 000 R.STS	EI
   170.272  305         	PUSH	B	save (BC)
A  170.273  333 177     	IN	DP.DC
A  000.000              	ERRNZ	DF.HD-1
O  170.275  000 000 000 	RAR
   170.300  332 343 170 	JC	STS2	Am currently over hole
O  170.303  000 000 000 	
                        *	No hole yet. Wait 8 mS minimum (10 max) for hole to appear
O  170.306  000 000 000 
UA 170.311  041 000 000 	LXI	H,.TICCNT
   170.314  106         	MOV	B,M	(B) = current time
A  170.315  333 177     STS1	IN	DP.DC
                        **** LINE 2679 PAGE 54
O  170.317  000 000 000 	RAR
A  000.000              	ERRNZ	DF.HD-1
   170.322  332 343 170 	JC	STS2	Got hole
   170.325  072 217 042 	LDA	D.STSA	(A) = delay count
   170.330  200         	ADD	B	10 mS max, 8mS min 
   170.331  276         	CMP	M
   170.332  302 315 170 	JNE	STS1	8 mS not up yet
                                                  	HEATH ASM #104.01.00.
                                                   	Page 41

   170.335  303 354 170 	JMP	STS3	Am in sector gap
O  170.340  000 000 000 	
                        * 	Have hole. Skip it and wait 12 mS
   170.343  315 042 171 STS2	CALL	WNH	Wait for no hole
   170.346  072 220 042 	LDA	D.STSB	(A) = count (10 mS min, 12 mS max)
   170.351  315 344 042 	CALL	D.DLY	Wait
   170.354  301         STS3	POP	B	Restore (BC)
O  170.355  000 000 000 	DI
                        *	JMP	WHD	Wait hole detect {source disabled}
O  170.360  000 000 000 
                        ***	WHD - Wait hole detect
                        *	WHD waits until a hole is located
                        *
                        *	ENTRY	None
                        *	EXIT	None
                        *	USES	A,F
O  170.363  000 000 000 
A  170.366  333 177     WHD	IN	DP.DC
A  000.000              	ERRNZ	DF.HD-1
O  170.370  000 000 000 	RAR
   170.373  322 366 170 	JNC	WHD	Wait until found
U  170.376  072 000 000 	LDA	D.WHDA	(A) = loop delay count
A  171.001  303 325 042 	JMP	D.UDLY
O  171.004  000 000 000 
                        ***	STZ - seek track zero
                        *	STZ seeks the selected unit arm outwards until it reaches
                        *	Track 0
                        *
                        *	The arm position byte is then updated to 0
                        *
                        *	ENTRY	Interrupts enabled
                        *	EXIT	Interrrups enabled
                        *	USES	A,F,H,L
O  171.007  000 000 000 
   171.012  315 303 042 STZ0	CALL	D.MAO	Move arm out
A  171.015  333 177     R.STZ	IN	DP.DC
UA 171.017  346 000     	ANI	DF.T0
   171.021  312 012 171 	JZ	STZ0	Not track 0 yet
A  171.024  052 365 042 	LHLD	D.TRKPT
   171.027  066 000     	MVI	M,0	Set track pointer
O  171.031  000 000 000 	RET
O  171.034  000 000 000 	
                        ***	WNH - wait for no hole
                        *	WNH waits until the current hole is past
                        *
                        *	ENTRY	None
                        *	EXIT	None
                        *	USES	A,F
O  171.037  000 000 000 
A  171.042  333 177     WNH	IN	DP.DC
A  000.000              	ERRNZ	DF.HD-1
O  171.044  000 000 000 	RAR
   171.047  332 042 171 	JC	WNH	Still hole
   171.052  072 222 042 	LDA	D.WNHA	(A) = debounce count
   171.063              .	SET	R.UDLY	Reference to R.UDLY
                        *	JMP	D.UDLY	Wait a little
O  171.055  000 000 000 
                        *** 	UDLY - microsectond delay
                                                  	HEATH ASM #104.01.00.
                                                   	Page 42

                        *	UDLY is called (with interrupts disabled)
                        *	to wait a certain number of microseconds
                        *
                        *	Each time through the delay loop causes a pause of
                        *	15/2.048 uS
                        *
                        *	ENTRY	(A) = loop count (zero taken as 256)
                        *	EXIT	(A) = 0
                        *	USES	A, F
O  171.060  000 000 000 
   171.063  075         R.UDLY	DCR	A
A  171.064  302 063 171 	JNZ	R.UDLY
O  171.067  000 000 000 	RET
O  171.072  000 000 000 	
                        ***	WSC - wait for sync character
                        *	WSC waits for the appearance of a sync character. The disk should be
                        *	selected, moving, and the head should be over the pre-syn zero band.
                        *
                        *	If a sync is not detected in 25 character times, an error is returned.
                        *
                        *	ENTRY	None
                        *	EXIT	'C' clear if ok, sync character read
                        *		(D) = 0 (checksum)
                        *		'C' set if no sync found
                        *	USES	A,F, D
O  171.075  000 000 000 
A  171.100  076 375     R.WSC	MVI	A,C.DSYN
   171.102  323 176     	OUT	UP.SC	
   171.104  333 176     	IN	UP.SR	
   171.106  072 223 042 	LDA	D.WSCA	(A) = NUMBER OF LOOPS IN 25 CHARACTERS
   171.111  127         	MOV	D,A
A  171.112  333 177     WSC1	IN	DP.DC
   171.114  346 010     	ANI	DF.SD	See if sync
   171.116  302 137 171 	JNZ	WSC2	got sync
   171.121  025         	DCR	D
   171.122  302 112 171 	JNZ	WSC1	Try some more
O  171.125  000 000 000 	
                        *	couldn't find sync
   171.130  067         	STC		Can't find sync	
O  171.131  000 000 000 	RET
O  171.134  000 000 000 	
                        *	Found sync
   171.137  333 174     WSC2	IN 	UP.DP	Gobble sync character
   171.141  026 000     	MVI	D,0	Clear checksum
O  171.143  000 000 000 	RET
O  171.146  000 000 000 
                        ***	WSP - write sync pattern
                        *	WSP writes a sync pattern of zeros, followed by a sync character.
                        *
                        *	ENTRY	(A) = initial delay counter
                        *		(C) = # of zero bytes to write
                        *	EXIT	(D) = checksum
                        *		(C) = 0
                        *	USES	A,F,C,D,E
O  171.151  000 000 000 
   171.154  075         R.WSP	DCR	A
   171.155  302 154 171 	JNZ	R.WSP	DELAY
O  171.160  000 000 000 	
                                                  	HEATH ASM #104.01.00.
                                                   	Page 43

                        *	delay is up on write gate
A  171.163  072 357 042 	LDA	D.DVCTL
A  000.000              	ERRNZ	DF.WG-1
   171.166  074         	INR	A	Set write gate
   171.167  323 177     	OUT	DP.DC	Set gate
O  171.171  000 000 000 	
                        *	Used as an entry point by DDIAG 
   171.174  257         WSP1	XRA	A
A  171.175  315 336 042 	CALL	D.WNB
   171.200  015         	DCR	C
   171.201  302 174 171 	JNZ	WSP1	Do more
A  171.204  076 375     	MVI	A,C.DSYN
   171.206  127         	MOV	D,A	Pre-clear checksum so WNB exits with (D) = 0
   171.207  303 336 042 	JMP	D.WNB	Write next byte
O  171.212  000 000 000 	
                        ***	WNB - Write next byte
                        *	WNB write a byte to the disk, assuming that the write gate
                        *	is already selected
                        *
                        *	ENTRY	(A) = character
O  171.215  000 000 000 		(D) = checksum
                        *	EXIT	(D) = checksum
                        *	USES	A,F,D,E
O  171.220  000 000 000 	
   171.223  137         R.WNB	MOV	E,A
A  171.224  333 175     WNB1	IN	UP.ST
   171.226  247         	ANA	A
A  000.000              	ERRNZ	UF.TBM-200Q
   171.227  362 224 171 	JP	WNB1	Not ready	
   171.232  173         	MOV	A,E
   171.233  323 174     	OUT	UP.DP	Out data
   171.235  252         	XRA	D
O  171.236  000 000 000 	RLC
   171.241  127         	MOV	D,A
O  171.242  000 000 000 	RET
O  171.245  000 000 000 	
A  171.250  000         	DB	'G+S'
O  171.251  000 000 000 	
                        ***	Boot code
                        *	Entered to boot system
O  171.254  000 000 000 
   171.257  363         BOOT	DI		Want no trouble with interrupts!
   171.260  061 200 042 	LXI	SP,STACK	Clear stack
UA 171.263  001 000 000 	LXI	B,BOOTAL
UA 171.266  021 000 000 	LXI	D,BOOTA
A  171.271  041 110 040 	LXI	H,D.CON
U  171.274  315 000 000 	CALL	$MOVE	Move in constants and vectors
O  171.277  000 000 000 	
                        *	ZERO WORK FIELD
A  171.302  041 240 040 	LXI	H,D.RAM
AV 171.305  006 025     	MVI	B,D.RAML
   171.307  315 002 162 	CALL	$ZERO	Zero memory
A  171.312  062 176 114 	STA	AIO.UNI
   171.315  323 177     	OUT	DP.DC	Off disk
O  171.317  000 000 000 
                        *	Setup all interrupt vectors to an EI/RET sequence
UAP377.377              	ERRNZ	UO.CLK-1
   171.322  074         	INR	A	
                                                  	HEATH ASM #104.01.00.
                                                   	Page 44

UA 171.323  062 000 000 	STA	.MFLAG
O  171.326  000 000 000 	
U  171.331  041 000 000 	LXI	H,.UIVEC	(HL) = .UIVEC address, (A) = 1
   171.334  066 303     BOOT2	MVI	M,303Q	
   171.336  043         	INX	H
UA 171.337  066 000     	MVI	M,$EIXIT
   171.341  043         	INX	H
A  171.342  066 165     	MVI	M,EIXIT/256
   171.344  043         	INX	H
   171.345  207         	ADD	A	Shift '1' into (A) left 1
   171.346  362 334 171 	JP	BOOT2	More to go
O  171.351  000 000 000 	
                        *	Setup clock interrupts
A  171.354  041 223 165 BOOT3	LXI	H,CLOCK
UA 171.357  042 001 000 	SHLD	.UIVEC+1
O  171.362  000 000 000 	EI
O  171.365  000 000 000 	
                        *	Read boot code
U  171.370  315 000 000 	CALL	R.ABORT	
A  171.373  021 200 042 	LXI	D,USERFWA
A  171.376  001 000 011 	LXI	B,9*256
A  172.001  041 000 000 	LXI	H,0
   172.004  315 301 165 	CALL	R.READ	
   172.007  322 200 042 	JNC	USERFWA	
O  172.012  000 000 000 	
                        *	WAIT FOR CHARACTER TO BE ENTERED.
O  172.015  000 000 000 	HLT
   172.020  303 257 171 	JMP	BOOT	Boot again
O  172.023  000 000 000 	
                        ****** page 59  
                        ***	disk constant and vector initialization table
A                       BOOTA	EQU	*
UAP167.330              	ERRNZ	*-BOOTA+D.CON-D.XITA
   172.026  170 002     	DW	2*256+120	Head unsettle and motor on times
O  172.030  000 000 000 	
UAP167.333              	ERRNZ	*-BOOTA+D.CON-D.WRITA
   172.033  024 000     	DW	20	Guardband count for write
O  172.035  000 000 000 	
UAP167.337              	ERRNZ	*-BOOTA+D.CON-D.WRITB
   172.040  012 000     	DW	10	Number of zero characters after hold edge
                        ***** line 2933 on page 59
UAP167.340              	ERRNZ	*-BOOTA+D.CON-D.WRITC
   172.042  020 000     	DW	128/8	Two character delay before writing
O  172.044  000 000 000 	
UAP167.344              	ERRNZ	*-BOOTA+D.CON-D.MAIA
   172.047  017 000     	DW	15	Track-to-track step times
O  172.051  000 000 000 	
UAP167.350              	ERRNZ	*-BOOTA+D.CON-D.LPSA
   172.054  024 000     	DW	20	Number of trys for correct sector
O  172.056  000 000 000 	
UAP167.354              	ERRNZ	*-BOOTA+D.CON-D.SDPA
   172.061  021 000     	DW	70/4	70 mS wait for heat settle
O  172.063  000 000 000 	
UAP167.360              	ERRNZ	*-BOOTA+D.CON-D.SDPB
   172.066  372 000     	DW	1000/4	1 second wait for motor on
O  172.070  000 000 000 	
UAP167.364              	ERRNZ	*-BOOTA+D.CON-D.STSA
   172.073  005 000     	DW	8/2+1	mS/2 to wait for index hole
                                                  	HEATH ASM #104.01.00.
                                                   	Page 45

O  172.075  000 000 000 	
UAP167.370              	ERRNZ	*-BOOTA+D.CON-D.STSB
   172.100  007 000     	DW	12/2+1	mS/2 to wait past index hole
O  172.102  000 000 000 	
UAP232.215              	ERRNZ	*-BOOTA+D.CON-D.WHDA
   172.105  024 000     	DW	20	UDLY count for hole debounce
O  172.107  000 000 000 	
UAP170.000              	ERRNZ	*-BOOTA+D.CON-D.WNHA
   172.112  024 000     	DW	20	UDlY count for hole debounce
O  172.114  000 000 000 	
UAP170.004              	ERRNZ	*-BOOTA+D.CON-D.WSCA
   172.117  120 000     	DW	64*25/20	Loop count for 25 characters
O  172.121  000 000 000 
                        ***	ERRT - Error test loop
   172.124  064         R.ERRT	INR	M	Count error
   172.125  311         	RET		Exit
O  172.126  000 000 000 	
                        *	JMP Vectors
U  172.131  303 000 000 	JMP	R.SYDD	D.SYDD (must be first)
U  172.134  303 000 000 	JMP	R.MOUNT	D.MOUNT
   172.137  303 161 165 	JMP	R.XOK	D.XOK
U  172.142  303 000 000 	JMP	R.ABORT	D.ABORT
   172.145  303 162 165 	JMP	R.XIT	D.XIT
   172.150  303 301 165 	JMP	R.READ	D.READ
   172.153  303 203 166 	JMP	R.READR	D.READR
U  172.156  303 000 000 	JMP	R.WRITE	D.WRITE
U  172.161  303 000 000 	JMP	R.CDE	D.CDE
   172.164  303 142 167 	JMP	R.DTS	D.DTS
   172.167  303 206 167 	JMP	R.SDT	D.SDT
   172.172  303 246 167 	JMP	R.MAI	D.MAI
   172.175  303 254 167 	JMP	R.MAO	D.MAO
   172.200  303 337 167 	JMP	R.LPS	D.LPS
   172.203  303 117 170 	JMP	R.RDB	D.RDB
   172.206  303 147 170 	JMP	R.SDP	D.SDP
U  172.211  303 000 000 	JMP	R.STS	D.STS
   172.214  303 015 171 	JMP	R.STZ	D.STZ
   172.217  303 063 171 	JMP	R.UDLY	D.UDLY
   172.222  303 100 171 	JMP	R.WSC	D.WSC
   172.225  303 154 171 	JMP	R.WSP	D.WSP
   172.230  303 223 171 	JMP	R.WNB	D.WNB
   172.233  303 124 172 	JMP	R.ERRT	D.ERRT
   172.236  303 306 167 	JMP	R.DLY	D.DLY
UA                      BOOTAL	EQU	*-BOOTA
O  172.241  000 000 000 
                        ***	DDIAG - initial deive diagnosis
A                       DDIAG	EQU	*
A  172.244  076 031     	MVI	A,DF.MO+DF.DS2+DF.WG
   172.246  323 177     	OUT	DP.DC	On disk
A  172.250  016 372     	MVI	C,250
   172.252  171         	MOV	A,C	(A) = 250
A  172.253  315 306 167 	CALL	R.DLY
   172.256  171         	MOV	A,C	(A) = 250
   172.257  315 306 167 	CALL	R.DLY	delay 1 second
O  172.262  000 000 000 	DI
U  172.265  315 000 000 	CALL	DDIAGO	Do check, return if error
O  172.270  000 000 000 	
                        *	Disk Diagnostic error
O  172.273  000 000 000 	EI
                                                  	HEATH ASM #104.01.00.
                                                   	Page 46

O  172.276  000 000 000 	HLT
O  172.301  000 000 000 	
                        *	Test disk
   172.304  315 174 171 DDIAG0	CALL	WSP1	Write sync pattern
A  172.307  001 134 014 	LXI	B,3164
A  172.312  076 107     DDIAG1	MVI	A,'G'
   172.314  315 223 171 	CALL	R.WNB	Write byte
   172.317  013         	DCX	B
   172.320  170         	MOV	A,B
   172.321  261         	ORA	C
A  172.322  302 312 172 	JNZ	DDIAG1
A  172.325  076 030     	MVI	A,30Q
   172.327  323 177     	OUT	DP.DC	Off write select
O  172.331  000 000 000 	
                        *	Now try read
A  172.334  076 333     	MVI	A,219
   172.336  062 223 042 	STA	D.WSCA	Wait for 68 chars max
   172.341  315 100 171 	CALL	R.WSC	Wait for sync detect
   172.344  330         	RC		Error
   172.345  001 132 014 	LXI	B,3164-2	Allow USART to gobble two during write 
   172.350  315 117 170 DDIAG2	CALL	R.RDB	Read byte
A  172.353  376 107     	CPI	'G'
   172.355  300         	RNE		Error
   172.356  013         	DCX	B
   172.357  170         	MOV	A,B
   172.360  261         	ORA	C
A  172.361  302 350 172 	JNZ	DDIAG2
   172.364  373         	EI		Restore interrupts
   172.365  166         	HLT		Ok
O  172.366  000 000 000 	
   172.371  000 112 107 	DB	0,'JGL',0	Error routing code
A  172.376  000         	DB	'HEATH'
A  172.377  000         	DB	0
O  173.000  000 000 000 	
P  133.002              	ERRPL	*-40001A	Overflow
O  173.003  000 000 000 	END
                        **** END of original listing
O  173.006  000 000 000 
O  173.011  000 000 000 
O  173.014  000 000 000 
O  173.017  000 000 000 
O  173.022  000 000 000 
O  173.025  000 000 000 
O  173.030  000 000 000 
O  173.033  000 000 000 
O  173.036  000 000 000 
O  173.041  000 000 000 		
O  173.044  000 000 000 
UA 173.047  000         	END Statement Missing


02659 Statements Assembled
38106 Bytes Free
00734 Errors Detected
                                                                                                            